<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MAPEx — Understanding Mean Absolute Percentage Error Over Forecast Horizons</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Source+Sans+3:wght@300;400;600;700&family=Source+Serif+4:opsz,wght@8..60,400;8..60,600;8..60,700&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
  <style>
    /* ── Reset & Base ── */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --bg: #fafaf9;
      --text: #1c1917;
      --text-muted: #57534e;
      --accent: #6d28d9;
      --accent-light: #ede9fe;
      --accent-mid: #a78bfa;
      --orange: #ea580c;
      --orange-light: #fff7ed;
      --teal: #0d9488;
      --teal-light: #f0fdfa;
      --red: #dc2626;
      --blue: #2563eb;
      --green: #16a34a;
      --border: #e7e5e4;
      --card-bg: #ffffff;
      --code-bg: #f5f5f4;
      --serif: 'Source Serif 4', Georgia, serif;
      --sans: 'Source Sans 3', system-ui, -apple-system, sans-serif;
      --mono: 'Fira Code', 'SF Mono', monospace;
      --max-w: 740px;
      --wide-max-w: 960px;
    }

    html { scroll-behavior: smooth; font-size: 18px; }

    body {
      font-family: var(--sans);
      background: var(--bg);
      color: var(--text);
      line-height: 1.7;
      -webkit-font-smoothing: antialiased;
    }

    /* ── Hero ── */
    .hero {
      text-align: center;
      padding: 5rem 2rem 4rem;
      background: linear-gradient(180deg, var(--accent-light) 0%, var(--bg) 100%);
      border-bottom: 1px solid var(--border);
    }

    .hero-badge {
      display: inline-block;
      background: var(--accent);
      color: #fff;
      font-size: 0.7rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      padding: 0.3em 1em;
      border-radius: 100px;
      margin-bottom: 1.5rem;
    }

    .hero h1 {
      font-family: var(--serif);
      font-size: clamp(2.4rem, 6vw, 3.6rem);
      font-weight: 700;
      line-height: 1.15;
      color: var(--text);
      max-width: 800px;
      margin: 0 auto 1rem;
    }

    .hero h1 span { color: var(--accent); }

    .hero p {
      font-size: 1.15rem;
      color: var(--text-muted);
      max-width: 560px;
      margin: 0 auto;
      line-height: 1.6;
    }

    /* ── Article body ── */
    .article { max-width: var(--max-w); margin: 0 auto; padding: 3rem 1.5rem 5rem; }

    .article h2 {
      font-family: var(--serif);
      font-size: 1.8rem;
      font-weight: 700;
      margin: 3.5rem 0 1rem;
      color: var(--text);
    }

    .article h3 {
      font-family: var(--serif);
      font-size: 1.3rem;
      font-weight: 600;
      margin: 2.5rem 0 0.75rem;
    }

    .article p { margin-bottom: 1.25rem; color: var(--text); }
    .article p.muted { color: var(--text-muted); font-size: 0.95rem; }

    .article a { color: var(--accent); text-decoration: underline; text-underline-offset: 2px; }
    .article a:hover { color: var(--orange); }

    .highlight { color: var(--accent); font-weight: 600; }
    .highlight-orange { color: var(--orange); font-weight: 600; }
    .highlight-teal { color: var(--teal); font-weight: 600; }

    /* ── Formula card ── */
    .formula-card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 2rem;
      margin: 1.5rem 0 2rem;
      text-align: center;
      box-shadow: 0 1px 3px rgba(0,0,0,0.04);
    }

    .formula-card .formula {
      font-family: var(--mono);
      font-size: 1.1rem;
      line-height: 2;
      color: var(--text);
    }

    .formula .f-var { color: var(--accent); font-weight: 500; }
    .formula .f-actual { color: var(--teal); font-weight: 500; }
    .formula .f-pred { color: var(--orange); font-weight: 500; }
    .formula .f-op { color: var(--text-muted); }

    .formula-card .formula-label {
      display: block;
      margin-top: 0.75rem;
      font-size: 0.8rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    /* ── Visualization containers ── */
    .vis-wide {
      max-width: var(--wide-max-w);
      margin: 2rem auto;
      padding: 0 1.5rem;
    }

    .vis-card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1.5rem 1.5rem 1rem;
      margin: 2rem 0;
      box-shadow: 0 1px 3px rgba(0,0,0,0.04);
      overflow: hidden;
    }

    .vis-card h4 {
      font-family: var(--sans);
      font-size: 0.8rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
      margin-bottom: 1rem;
    }

    .vis-card svg { display: block; width: 100%; height: auto; }

    /* ── Interactive controls ── */
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 1.25rem;
      align-items: center;
      margin-bottom: 1.25rem;
      padding: 1rem 1.25rem;
      background: var(--code-bg);
      border-radius: 8px;
    }

    .control-group { display: flex; flex-direction: column; gap: 0.3rem; }

    .control-group label {
      font-size: 0.72rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
    }

    .control-group .value-display {
      font-family: var(--mono);
      font-size: 0.85rem;
      font-weight: 500;
      color: var(--accent);
      min-width: 3ch;
    }

    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 180px;
      height: 6px;
      border-radius: 3px;
      background: var(--border);
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px; height: 18px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      border: 2px solid #fff;
      box-shadow: 0 1px 4px rgba(0,0,0,0.2);
    }

    input[type="range"]::-moz-range-thumb {
      width: 18px; height: 18px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      border: 2px solid #fff;
      box-shadow: 0 1px 4px rgba(0,0,0,0.2);
    }

    /* ── Callout boxes ── */
    .callout {
      border-left: 4px solid var(--accent);
      background: var(--accent-light);
      padding: 1rem 1.25rem;
      border-radius: 0 8px 8px 0;
      margin: 1.5rem 0;
      font-size: 0.95rem;
    }

    .callout.callout-orange {
      border-left-color: var(--orange);
      background: var(--orange-light);
    }

    .callout.callout-teal {
      border-left-color: var(--teal);
      background: var(--teal-light);
    }

    .callout strong { font-weight: 700; }

    /* ── Step-through / scrollytelling ── */
    .step-cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin: 1.5rem 0 2rem;
    }

    .step-card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 1.25rem;
      text-align: center;
      transition: border-color 0.2s, box-shadow 0.2s;
    }

    .step-card:hover {
      border-color: var(--accent-mid);
      box-shadow: 0 2px 8px rgba(109,40,217,0.08);
    }

    .step-card .step-num {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 2rem; height: 2rem;
      border-radius: 50%;
      background: var(--accent);
      color: #fff;
      font-size: 0.8rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
    }

    .step-card h5 {
      font-size: 0.95rem;
      font-weight: 600;
      margin-bottom: 0.35rem;
    }

    .step-card p {
      font-size: 0.82rem;
      color: var(--text-muted);
      margin: 0;
      line-height: 1.5;
    }

    /* ── Table for MAPE calculation ── */
    .calc-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
      margin: 1rem 0;
    }

    .calc-table th {
      background: var(--code-bg);
      font-weight: 600;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--text-muted);
      padding: 0.6rem 0.75rem;
      text-align: center;
      border-bottom: 2px solid var(--border);
    }

    .calc-table td {
      padding: 0.55rem 0.75rem;
      text-align: center;
      border-bottom: 1px solid var(--border);
      font-family: var(--mono);
      font-size: 0.85rem;
    }

    .calc-table tr:last-child td { border-bottom: none; }
    .calc-table .col-actual { color: var(--teal); font-weight: 500; }
    .calc-table .col-pred { color: var(--orange); font-weight: 500; }
    .calc-table .col-error { color: var(--red); font-weight: 500; }

    .mape-result {
      text-align: center;
      font-family: var(--mono);
      font-size: 1.4rem;
      font-weight: 700;
      color: var(--accent);
      padding: 0.75rem;
      background: var(--accent-light);
      border-radius: 8px;
      margin: 1rem 0;
    }

    /* ── Horizon bar chart colors ── */
    .horizon-bar { transition: all 0.3s ease; }
    .horizon-bar:hover { opacity: 0.85; }

    /* ── Tooltip ── */
    .tooltip {
      position: absolute;
      pointer-events: none;
      background: var(--text);
      color: #fff;
      padding: 0.4rem 0.65rem;
      border-radius: 6px;
      font-size: 0.78rem;
      font-family: var(--mono);
      line-height: 1.4;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      opacity: 0;
      transition: opacity 0.15s;
      z-index: 100;
      white-space: nowrap;
    }

    /* ── Legend ── */
    .legend {
      display: flex;
      gap: 1.5rem;
      flex-wrap: wrap;
      margin-bottom: 0.75rem;
      font-size: 0.8rem;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      color: var(--text-muted);
    }

    .legend-swatch {
      width: 12px; height: 12px;
      border-radius: 3px;
      flex-shrink: 0;
    }

    /* ── Animated dot ── */
    @keyframes pulse {
      0%, 100% { r: 4; opacity: 1; }
      50% { r: 7; opacity: 0.6; }
    }

    .pulse-dot { animation: pulse 2s ease-in-out infinite; }

    /* ── Divider ── */
    .divider {
      border: none;
      height: 1px;
      background: var(--border);
      margin: 3rem 0;
    }

    /* ── Footer ── */
    .footer {
      text-align: center;
      padding: 2.5rem 1.5rem;
      border-top: 1px solid var(--border);
      color: var(--text-muted);
      font-size: 0.82rem;
    }

    .footer a { color: var(--accent); text-decoration: none; }
    .footer a:hover { text-decoration: underline; }

    /* ── Impact table ── */
    .impact-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
      margin: 1rem 0;
    }

    .impact-table th {
      background: var(--code-bg);
      font-weight: 600;
      font-size: 0.7rem;
      text-transform: uppercase;
      padding: 0.6rem 0.5rem;
      text-align: center;
      border: 1px solid var(--border);
    }

    .impact-table td {
      padding: 0.75rem 0.5rem;
      text-align: center;
      border: 1px solid var(--border);
      cursor: pointer;
      transition: background 0.2s;
    }

    .impact-table td:hover {
      background: var(--accent-light);
    }

    .impact-table td.current-month {
      background: var(--teal-light);
      color: var(--teal);
      font-weight: 600;
    }

    .impact-table td.next-month {
      background: var(--orange-light);
      color: var(--orange);
      font-weight: 600;
    }

    .impact-table td.both-months {
      background: linear-gradient(135deg, var(--teal-light) 50%, var(--orange-light) 50%);
      color: var(--text);
      font-weight: 600;
    }

    /* ── Responsive ── */
    @media (max-width: 640px) {
      html { font-size: 16px; }
      .hero { padding: 3rem 1.25rem 2.5rem; }
      .article { padding: 2rem 1.25rem 3rem; }
      input[type="range"] { width: 140px; }
      .controls { gap: 0.75rem; padding: 0.75rem; }
      .step-cards { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>

<!-- ══════════════ HERO ══════════════ -->
<header class="hero">
  <div class="hero-badge">Interactive Explainer</div>
  <h1>MAPE<span>x</span></h1>
  <p>A visual, interactive guide to <strong>Mean Absolute Percentage Error</strong> and how forecast accuracy changes across prediction horizons.</p>
</header>

<!-- ══════════════ ARTICLE ══════════════ -->
<main class="article">

  <!-- ── Section 1: What is Forecasting? ── -->
  <h2>Why Forecast Accuracy Matters</h2>
  <p>
    Organizations use forecasts to predict future demand, revenue, inventory needs, and more.
    A forecast is only useful if it's <em>accurate enough</em> to drive good decisions. But how
    do we measure "accurate enough"?
  </p>
  <p>
    One of the most widely used metrics is <span class="highlight">MAPE</span> — the
    <strong>Mean Absolute Percentage Error</strong>. It tells you, on average, how far off your
    predictions are from reality, expressed as a percentage.
  </p>

  <!-- ── Section 2: The MAPE Formula ── -->
  <h2>The MAPE Formula</h2>
  <p>MAPE is calculated in four intuitive steps:</p>

  <div class="step-cards">
    <div class="step-card">
      <div class="step-num">1</div>
      <h5>Error</h5>
      <p>Subtract the forecast from the actual value for each period.</p>
    </div>
    <div class="step-card">
      <div class="step-num">2</div>
      <h5>Absolute</h5>
      <p>Take the absolute value — we care about magnitude, not direction.</p>
    </div>
    <div class="step-card">
      <div class="step-num">3</div>
      <h5>Percentage</h5>
      <p>Divide by the actual value to get a relative error for each period.</p>
    </div>
    <div class="step-card">
      <div class="step-num">4</div>
      <h5>Mean</h5>
      <p>Average all the percentage errors across periods.</p>
    </div>
  </div>

  <div class="formula-card">
    <div class="formula" id="mape-formula"></div>
    <span class="formula-label">
      where <span class="f-actual">A<sub>t</sub></span> = actual value,
      <span class="f-pred">F<sub>t</sub></span> = forecast value,
      <span class="f-var">n</span> = number of periods
    </span>
  </div>

  <div class="callout callout-teal">
    <strong>Interpretation:</strong> A MAPE of 5% means your forecasts are, on average, 5% away from
    the actual values. Lower is better.
  </div>

  <!-- ── Section 3: Interactive MAPE Calculator ── -->
  <h2>See MAPE in Action</h2>
  <p>
    The table below shows a simple example. <strong>Drag the sliders</strong> to change the
    actual values and watch MAPE update in real time. The forecasts are held constant.
  </p>

  <div class="vis-card">
    <h4>Interactive MAPE Calculator</h4>
    <div id="calc-container">
      <table class="calc-table">
        <thead>
          <tr>
            <th>Period</th>
            <th>Actual (Aₜ) — drag to edit</th>
            <th>Forecast (Fₜ)</th>
            <th>|Aₜ − Fₜ| / |Aₜ|</th>
          </tr>
        </thead>
        <tbody id="calc-body"></tbody>
      </table>
      <div id="mape-result" class="mape-result"></div>
    </div>
  </div>

  <div class="callout callout-teal">
    <strong>Higher actuals help MAPE:</strong> When actual values increase but forecast errors
    stay the same in absolute terms, the percentage error decreases. For example, if forecast
    is off by 10 units: 10/100 = 10% error, but 10/200 = 5% error. MAPE is a relative metric,
    so larger denominators (actuals) reduce the percentage error.
  </div>

  <hr class="divider">

  <!-- ── Section 4: Understanding Horizon and Time Bucket ── -->
  <h2>Understanding Horizon and Time Bucket</h2>

  <div class="step-cards">
    <div class="step-card">
      <div class="step-num">1</div>
      <h5>Horizon (H days)</h5>
      <p>
        The period that includes all transactional activities from day 1 to day H.
        A 14-day horizon means forecasting for a consecutive 14-day window.
      </p>
    </div>
    <div class="step-card">
      <div class="step-num">2</div>
      <h5>Time Bucket</h5>
      <p>
        The aggregation period for estimates and actuals. For daily MAPEx,
        each version has a bucket [V, V+H&minus;1] over which we sum forecasts and actuals.
      </p>
    </div>
    <div class="step-card">
      <div class="step-num">3</div>
      <h5>Lag (Currently 0)</h5>
      <p>
        The delay between forecast generation and forecast period start.
        Lag=0 means forecasts generated on Monday cover Monday+H days.
        We use lag=0 for all MAPEx calculations.
      </p>
    </div>
  </div>

  <div class="callout">
    <strong>Example:</strong> On Monday Feb 16 with H=14 and lag=0, the forecast covers
    Feb 16 &ndash; Mar 1 (14 days). The time bucket = forecast period = [Feb 16, Mar 1].
  </div>

  <!-- ── Section 5: Interactive Time Series + Horizon ── -->
  <h2>Forecasts Across Horizons</h2>
  <p>
    The chart below shows actual values (solid line) and forecasts at different horizons.
    Use the slider to change the forecast horizon and observe how the predictions diverge from
    reality as we look further ahead.
  </p>

  <div class="vis-card">
    <h4>Actual vs. Forecast — Adjustable Horizon</h4>
    <div class="controls">
      <div class="control-group">
        <label>Forecast Horizon (x)</label>
        <div style="display:flex;align-items:center;gap:0.5rem;">
          <input type="range" id="horizon-slider" min="0" max="4" value="0" step="1">
          <span class="value-display" id="horizon-value">7</span>
          <span style="font-size:0.78rem;color:var(--text-muted);">days ahead</span>
        </div>
      </div>
    </div>
    <div class="legend">
      <div class="legend-item"><div class="legend-swatch" style="background:var(--teal)"></div> Actual</div>
      <div class="legend-item"><div class="legend-swatch" style="background:var(--orange)"></div> Forecast</div>
      <div class="legend-item"><div class="legend-swatch" style="background:rgba(234,88,12,0.15)"></div> Error region</div>
    </div>
    <div id="ts-chart"></div>
    <div id="ts-mape" class="mape-result" style="margin-top:0.75rem;"></div>
  </div>

  <hr class="divider">

  <!-- ── Section 6: MAPE vs Horizon ── -->
  <h2>MAPEx: Error Grows with Horizon</h2>
  <p>
    Now let's plot the MAPE <em>itself</em> for each horizon. This is the MAPEx curve — it shows
    how forecast quality degrades as we predict further into the future.
  </p>

  <div class="callout callout-teal" style="font-size:0.88rem;">
    <strong>Try it:</strong> Set noise to <strong>1</strong> vs <strong>8</strong> and see how the MAPEx curve changes. Higher noise shifts the entire curve upward.
  </div>

  <div class="vis-card">
    <h4>MAPEx — MAPE at Each Forecast Horizon</h4>
    <div class="legend" style="margin-bottom:0.5rem;">
      <div class="legend-item"><div class="legend-swatch" style="background:var(--accent)"></div> Current</div>
      <div class="legend-item"><div class="legend-swatch" style="background:#d4d4d4"></div> Previous (ghost)</div>
    </div>
    <div class="controls">
      <div class="control-group">
        <label>Noise Level</label>
        <div style="display:flex;align-items:center;gap:0.5rem;">
          <input type="range" id="noise-slider" min="1" max="10" value="4" step="1">
          <span class="value-display" id="noise-value">4</span>
        </div>
      </div>
      <div class="control-group">
        <label>Trend Strength</label>
        <div style="display:flex;align-items:center;gap:0.5rem;">
          <input type="range" id="trend-slider" min="0" max="10" value="3" step="1">
          <span class="value-display" id="trend-value">3</span>
        </div>
      </div>
    </div>
    <div id="mapex-chart"></div>
  </div>

  <p class="muted" style="text-align:center;margin-top:0.5rem;">In this demo, we simulate a recursive model: each step uses the previous forecast as input, so errors accumulate.</p>

  <p>
    Notice the characteristic upward shape: short horizons produce small errors, while
    longer horizons produce progressively larger errors. The rate of increase depends on
    the <span class="highlight-orange">noise</span> in the data and the
    <span class="highlight-teal">trend strength</span>.
  </p>

  <hr class="divider">

  <!-- ── Daily Versions Section ── -->
  <h2>The MAPEx Formula &mdash; Daily Versions</h2>
  <p>
    The correct MAPEx formula uses a <strong>rolling daily version</strong> approach.
    For each day (version date), we create a forecast for the next H days and compare
    it to actual values once they're available.
  </p>

  <div class="formula-card">
    <div class="formula" id="mapex-formula-daily"></div>
    <span class="formula-label">
      where each version V has a time bucket [V, V+H&minus;1],<br>
      TAE<sub>v</sub> = &Sigma;|F<sub>d</sub> &minus; A<sub>d</sub>| for d &isin; bucket,
      Actuals<sub>v</sub> = &Sigma; A<sub>d</sub> for d &isin; bucket
    </span>
  </div>

  <h3>Daily Versions Explained</h3>
  <p>
    For <strong>today = Feb 16, 2026</strong> and <strong>horizon = 14 days</strong>:
  </p>
  <ul style="margin:0.75rem 0 1.25rem 1.5rem;color:var(--text);">
    <li><strong>Version Feb 3:</strong> Bucket = Feb 3&ndash;16 (14 days), all actuals available &#10003;</li>
    <li><strong>Version Feb 2:</strong> Bucket = Feb 2&ndash;15 (14 days), all actuals available &#10003;</li>
    <li>...going back to <strong>Version Jan 20:</strong> Bucket = Jan 20 &ndash; Feb 2</li>
  </ul>
  <p>
    For February MAPEx (H=14), we aggregate versions from <strong>Jan 20 to Feb 3</strong>
    (all versions where the bucket falls within or overlaps February and actuals are available).
  </p>

  <div class="vis-card">
    <h4>Daily Versions Visualized &mdash; Rolling Windows</h4>
    <div class="controls">
      <div class="control-group">
        <label>Horizon (H)</label>
        <select id="daily-horizon-select" style="font-size:0.85rem;padding:0.3em 0.5em;border-radius:6px;border:1px solid var(--border);">
          <option value="7">7 days</option>
          <option value="14" selected>14 days</option>
          <option value="21">21 days</option>
          <option value="28">28 days</option>
          <option value="35">35 days</option>
        </select>
      </div>
      <div class="control-group">
        <label>Show Version</label>
        <div style="display:flex;align-items:center;gap:0.5rem;">
          <input type="range" id="version-slider" min="0" max="15" value="0" step="1">
          <span class="value-display" id="version-date-display">Feb 3</span>
        </div>
      </div>
    </div>
    <div class="legend">
      <div class="legend-item"><div class="legend-swatch" style="background:var(--teal)"></div> Actual</div>
      <div class="legend-item"><div class="legend-swatch" style="background:var(--orange)"></div> Forecast</div>
      <div class="legend-item"><div class="legend-swatch" style="background:rgba(109,40,217,0.08);border:1px dashed var(--accent)"></div> Time Bucket</div>
    </div>
    <div id="daily-versions-chart"></div>
    <div class="mape-result" id="version-stats"></div>
  </div>

  <hr class="divider">

  <!-- ── Forecast Revision Impact Grid ── -->
  <h2>Forecast Revision Impact Across Horizons</h2>
  <p>
    When you edit a forecast in a specific week, it affects different horizon/month
    combinations. The table below shows which months are impacted for each horizon.
  </p>

  <div class="vis-card">
    <h4>Forecast Edit Impact Matrix</h4>
    <table class="impact-table" id="impact-table">
      <thead>
        <tr>
          <th>Editing Week</th>
          <th>H=7 Days</th>
          <th>H=14 Days</th>
          <th>H=21 Days</th>
          <th>H=28 Days</th>
          <th>H=35 Days</th>
        </tr>
      </thead>
      <tbody id="impact-body"></tbody>
    </table>
    <p class="muted" style="margin-top:1rem;text-align:center;">
      Click on a cell to see which months are affected by editing that week's forecast.
    </p>
    <div id="impact-result" class="mape-result" style="display:none;"></div>
  </div>

  <hr class="divider">

  <!-- ── Section 7: Why does error grow? ── -->
  <h2>Why Does Error Grow with Horizon?</h2>

  <div class="step-cards">
    <div class="step-card">
      <div class="step-num" style="background:var(--orange)">1</div>
      <h5>Error Accumulation</h5>
      <p>Recursive models feed predictions back as inputs. Small errors compound at each step.</p>
    </div>
    <div class="step-card">
      <div class="step-num" style="background:var(--orange)">2</div>
      <h5>Increasing Uncertainty</h5>
      <p>The further ahead we look, the more unforeseen events can occur. The future is fundamentally uncertain.</p>
    </div>
    <div class="step-card">
      <div class="step-num" style="background:var(--orange)">3</div>
      <h5>Signal Decay</h5>
      <p>Recent observations carry strong signal. As the horizon grows, the model must rely on weaker, older patterns.</p>
    </div>
  </div>

  <hr class="divider">

  <!-- ── Section 8: Interpreting MAPE ── -->
  <h2>Interpreting MAPE Values</h2>

  <div class="vis-card">
    <h4>MAPE Quality Benchmarks</h4>
    <div id="benchmark-chart"></div>
  </div>

  <p class="muted">
    These benchmarks are rough rules of thumb. What counts as "good" depends entirely on the
    domain — a 10% MAPE might be excellent for long-range energy demand forecasts but
    unacceptable for short-term stock predictions.
  </p>

  <hr class="divider">

  <!-- ── Section 9: Limitations ── -->
  <h2>Limitations of MAPE</h2>

  <div class="callout callout-orange">
    <strong>Division by zero:</strong> If any actual value Aₜ is zero, MAPE is undefined.
    This makes MAPE unsuitable for intermittent or sparse data.
  </div>

  <p>
    <strong>Asymmetric penalty:</strong> MAPE penalizes over-forecasts more heavily than
    under-forecasts. A forecast of 150 when actual is 100 gives 50% error, but a forecast
    of 50 when actual is 100 also gives 50%. However, there's no upper bound for over-forecasting
    errors while under-forecasting errors cap at 100%.
  </p>

  <p>
    <strong>Scale sensitivity at low volumes:</strong> If actual demand is 2 units and you forecast 1,
    the percentage error is 50% — despite only being off by a single unit.
  </p>

  <div class="callout callout-orange">
    <strong>Volume weighting across SKUs:</strong> When computing MAPEx across multiple SKUs
    (products), high-volume items dominate the aggregate MAPE since their absolute errors are
    larger. A single best-selling SKU can skew the overall MAPEx curve, masking poor performance
    on low-volume items. Consider computing MAPE per-SKU first, then averaging, or use WMAPE
    to explicitly weight by volume.
  </div>

  <h3>Alternatives</h3>
  <p>
    Consider <strong>WMAPE</strong> (Weighted MAPE) for handling varying magnitudes,
    <strong>MASE</strong> (Mean Absolute Scaled Error) for a scale-free metric that avoids the
    division-by-zero problem, or <strong>RMSE</strong> (Root Mean Squared Error) when large errors
    matter disproportionately.
  </p>

  <hr class="divider">

  <!-- ── Section 10: Upload your own data ── -->
  <h2>Try Your Own Data</h2>
  <p>
    Upload a CSV with columns <code>actual</code> and <code>forecast</code> to compute your
    own MAPE. Optionally include a <code>horizon</code> column (e.g. 7, 14, 21, 28, 35) to
    see your own MAPEx curve.
  </p>

  <div class="vis-card">
    <h4>CSV Upload</h4>
    <div class="controls" style="flex-direction:column;align-items:flex-start;">
      <div style="display:flex;align-items:center;gap:1rem;flex-wrap:wrap;">
        <input type="file" id="csv-upload" accept=".csv" style="font-size:0.85rem;">
        <button id="csv-sample-btn" style="font-size:0.78rem;padding:0.4em 1em;border-radius:6px;border:1px solid var(--accent);background:var(--accent-light);color:var(--accent);cursor:pointer;font-weight:600;">Load sample data</button>
      </div>
      <p id="csv-status" class="muted" style="margin:0.5rem 0 0;font-size:0.8rem;"></p>
    </div>
    <div id="csv-result" style="display:none;">
      <div id="csv-mape-result" class="mape-result"></div>
      <div id="csv-mapex-chart" style="margin-top:1rem;"></div>
    </div>
  </div>

  <hr class="divider">

  <!-- ── Section 11: Horizon Lag Visualization ── -->
  <h2>Understanding Horizon Lag</h2>
  <p>
    When you forecast at horizon <span class="highlight-orange">x</span>, you're predicting
    the value <em>x days from now</em> using only data available <em>today</em>. The gap between
    the last known data point and the prediction target is the <strong>lag</strong>.
  </p>
  <p>
    The visualization below shows this for each horizon. The solid region is known data,
    the gap is the lag (the blind spot), and the point at the end is what the model must predict.
    As the horizon grows, the lag grows — and the model has less relevant information to work with.
  </p>

  <div class="vis-card">
    <h4>Horizon Lag — What the Model "Sees" vs. What It Must Predict</h4>
    <div id="lag-chart"></div>
  </div>

  <p>
    At <span class="highlight">day 7</span>, the model predicts just one week out — the lag is
    short and recent patterns are still relevant. By <span class="highlight-orange">day 35</span>,
    the model must bridge a five-week gap, during which demand patterns, seasonality, and external
    factors can all shift. This is why MAPEx increases with horizon.
  </p>

  <hr class="divider">

  <!-- ── Section 12: Takeaways ── -->
  <h2>Key Takeaways</h2>
  <div class="step-cards">
    <div class="step-card" style="border-color:var(--accent-mid)">
      <h5>MAPE is intuitive</h5>
      <p>A percentage-based error that's easy to communicate and compare across datasets.</p>
    </div>
    <div class="step-card" style="border-color:var(--accent-mid)">
      <h5>Horizon matters</h5>
      <p>MAPEx reveals how accuracy degrades as you forecast further ahead — essential for setting expectations.</p>
    </div>
    <div class="step-card" style="border-color:var(--accent-mid)">
      <h5>Know the limits</h5>
      <p>MAPE struggles with zeros, is asymmetric, and is sensitive to small actuals. Pair it with other metrics.</p>
    </div>
  </div>

</main>

<!-- ══════════════ FOOTER ══════════════ -->
<footer class="footer">
  <p>
    <strong>MAPEx</strong> — An interactive explainer on forecast accuracy.
    Built with <a href="https://d3js.org/" target="_blank" rel="noopener">D3.js</a>.
  </p>
</footer>

<!-- ══════════════ TOOLTIP ══════════════ -->
<div class="tooltip" id="tooltip"></div>

<!-- ══════════════ SCRIPTS ══════════════ -->
<script>
(function () {
  "use strict";

  const accent = "#6d28d9";
  const orange = "#ea580c";
  const teal = "#0d9488";
  const red = "#dc2626";
  const green = "#16a34a";
  const blue = "#2563eb";
  const textMuted = "#57534e";
  const border = "#e7e5e4";
  const ghost = "#d4d4d4";

  // Day-based horizons
  const HORIZONS = [7, 14, 21, 28, 35];

  const tooltip = d3.select("#tooltip");

  function showTooltip(evt, html) {
    tooltip.html(html).style("opacity", 1);
    const ttNode = tooltip.node();
    const ttRect = ttNode.getBoundingClientRect();
    let left = evt.pageX + 12;
    let top = evt.pageY - 28;
    if (left + ttRect.width > window.innerWidth - 16) left = evt.pageX - ttRect.width - 12;
    tooltip.style("left", left + "px").style("top", top + "px");
  }

  function hideTooltip() { tooltip.style("opacity", 0); }

  /* ═══════════════════════════════════════
     1) Interactive MAPE Calculator Table
        Actuals are editable, Forecasts are constant
     ═══════════════════════════════════════ */
  const calcActuals = [100, 120, 90, 110, 105];
  const calcForecasts = [95, 130, 85, 100, 115]; // constant

  function renderCalcTable() {
    const tbody = d3.select("#calc-body");
    tbody.selectAll("tr").remove();

    let sumPctErr = 0;
    calcActuals.forEach((a, i) => {
      const f = calcForecasts[i];
      const pctErr = a !== 0 ? Math.abs(a - f) / Math.abs(a) : 0;
      sumPctErr += pctErr;

      const tr = tbody.append("tr");
      tr.append("td").text("t" + (i + 1));

      // Actual column: editable slider
      const tdA = tr.append("td");
      const inp = tdA.append("input")
        .attr("type", "range")
        .attr("min", Math.round(f * 0.5))
        .attr("max", Math.round(f * 2))
        .attr("value", a)
        .style("width", "90px");
      tdA.append("span")
        .attr("class", "col-actual")
        .style("margin-left", "0.4rem")
        .style("font-family", "var(--mono)")
        .text(a);

      // Forecast column: constant display
      tr.append("td").attr("class", "col-pred").text(f);

      tr.append("td").attr("class", "col-error").text((pctErr * 100).toFixed(1) + "%");

      inp.on("input", function () {
        calcActuals[i] = +this.value;
        renderCalcTable();
      });
    });

    const mape = (sumPctErr / calcActuals.length) * 100;
    d3.select("#mape-result").text("MAPE = " + mape.toFixed(2) + "%");
  }
  renderCalcTable();

  /* ═══════════════════════════════════════
     2) Time Series Forecast Chart
     ═══════════════════════════════════════ */
  function seededRandom(seed) {
    let s = seed;
    return function () {
      s = (s * 16807 + 0) % 2147483647;
      return (s - 1) / 2147483646;
    };
  }

  const rng = seededRandom(42);
  const N = 30;
  const actuals = [];
  let val = 100;
  for (let i = 0; i < N; i++) {
    val += (rng() - 0.45) * 8 + 0.3;
    val = Math.max(val, 20);
    actuals.push(Math.round(val * 10) / 10);
  }

  // Generate forecasts with error proportional to horizon (in days)
  function generateForecasts(horizonDays) {
    const rng2 = seededRandom(123 + horizonDays);
    const factor = horizonDays / 7; // normalise so day 7 ≈ old horizon 1
    return actuals.map((a, i) => {
      const noise = (rng2() - 0.5) * 2 * factor * 2.2;
      const drift = factor * 0.4 * (rng2() - 0.45);
      return Math.round((a + noise + drift) * 10) / 10;
    });
  }

  function computeMAPE(act, pred) {
    let sum = 0;
    let n = 0;
    act.forEach((a, i) => {
      if (a !== 0 && pred[i] !== undefined) {
        sum += Math.abs(a - pred[i]) / Math.abs(a);
        n++;
      }
    });
    return n > 0 ? (sum / n) * 100 : 0;
  }

  const tsMargin = { top: 20, right: 20, bottom: 35, left: 50 };
  const tsContainer = d3.select("#ts-chart");

  // Real calendar dates starting Feb 16, 2026
  const tsToday = new Date(2026, 1, 16);
  const tsDates = d3.range(N).map(i => new Date(tsToday.getTime() + i * 86400000));
  const tsDateFmt = d3.timeFormat("%b %d");

  function renderTSChart() {
    tsContainer.selectAll("*").remove();
    const cw = tsContainer.node().getBoundingClientRect().width;
    const width = cw;
    const height = Math.min(340, cw * 0.5);
    const iw = width - tsMargin.left - tsMargin.right;
    const ih = height - tsMargin.top - tsMargin.bottom;

    const sliderIdx = +d3.select("#horizon-slider").property("value");
    const horizonDays = HORIZONS[sliderIdx];
    d3.select("#horizon-value").text(horizonDays);
    const forecasts = generateForecasts(horizonDays);
    const mape = computeMAPE(actuals, forecasts);
    const targetDate = new Date(tsToday.getTime() + horizonDays * 86400000);
    d3.select("#ts-mape").text(
      "MAPE at horizon " + horizonDays + " days (target: " + tsDateFmt(targetDate) + ") = " + mape.toFixed(2) + "%"
    );

    const svg = tsContainer.append("svg")
      .attr("viewBox", `0 0 ${width} ${height}`)
      .attr("preserveAspectRatio", "xMidYMid meet");

    const g = svg.append("g").attr("transform", `translate(${tsMargin.left},${tsMargin.top})`);

    const x = d3.scaleTime().domain([tsDates[0], tsDates[N - 1]]).range([0, iw]);
    const allVals = actuals.concat(forecasts);
    const y = d3.scaleLinear().domain([d3.min(allVals) - 5, d3.max(allVals) + 5]).range([ih, 0]);

    g.append("g").attr("transform", `translate(0,${ih})`)
      .call(d3.axisBottom(x).ticks(8).tickFormat(d3.timeFormat("%b %d")))
      .call(g => g.select(".domain").attr("stroke", border))
      .call(g => g.selectAll(".tick line").attr("stroke", border))
      .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.6rem"));

    g.append("g")
      .call(d3.axisLeft(y).ticks(6))
      .call(g => g.select(".domain").attr("stroke", border))
      .call(g => g.selectAll(".tick line").attr("stroke", border))
      .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.65rem"));

    g.append("g").attr("class", "grid")
      .call(d3.axisLeft(y).ticks(6).tickSize(-iw).tickFormat(""))
      .call(g => g.select(".domain").remove())
      .call(g => g.selectAll(".tick line").attr("stroke", border).attr("stroke-opacity", 0.5));

    // Error area
    const area = d3.area()
      .x((d, i) => x(tsDates[i]))
      .y0((d, i) => y(Math.min(actuals[i], forecasts[i])))
      .y1((d, i) => y(Math.max(actuals[i], forecasts[i])))
      .curve(d3.curveMonotoneX);

    g.append("path").datum(actuals).attr("d", area)
      .attr("fill", "rgba(234,88,12,0.12)").attr("stroke", "none");

    const lineGen = d3.line().x((d, i) => x(tsDates[i])).y(d => y(d)).curve(d3.curveMonotoneX);

    g.append("path").datum(actuals).attr("d", lineGen)
      .attr("fill", "none").attr("stroke", teal).attr("stroke-width", 2.5);

    g.append("path").datum(forecasts).attr("d", lineGen)
      .attr("fill", "none").attr("stroke", orange).attr("stroke-width", 2).attr("stroke-dasharray", "6 3");

    g.selectAll(".dot-actual").data(actuals).enter()
      .append("circle")
      .attr("cx", (d, i) => x(tsDates[i])).attr("cy", d => y(d)).attr("r", 3).attr("fill", teal)
      .on("mouseover", function (evt, d) {
        const i = actuals.indexOf(d);
        showTooltip(evt, `${tsDateFmt(tsDates[i])}<br>Actual: ${d}<br>Forecast: ${forecasts[i]}<br>Error: ${(Math.abs(d - forecasts[i]) / Math.abs(d) * 100).toFixed(1)}%`);
      })
      .on("mousemove", function (evt) { showTooltip(evt, tooltip.html()); })
      .on("mouseout", hideTooltip);
  }

  renderTSChart();
  d3.select("#horizon-slider").on("input", renderTSChart);

  /* ═══════════════════════════════════════
     3) MAPEx Chart — MAPE vs Horizon (days)
        with ghost bars for previous state
     ═══════════════════════════════════════ */
  const mapexMargin = { top: 20, right: 30, bottom: 40, left: 55 };
  let previousMapexData = null; // stores ghost data

  function computeMapexData(noise, trend) {
    const rng3 = seededRandom(77);
    const N2 = 60; // 60 days of data for daily versions
    const act2 = [];
    let v = 100;
    for (let i = 0; i < N2; i++) {
      v += (rng3() - 0.5) * noise * 1.5 + trend * 0.3;
      v = Math.max(v, 20);
      act2.push(Math.round(v * 10) / 10);
    }

    return HORIZONS.map(H => {
      const rng4 = seededRandom(200 + H);

      // Generate forecasts with horizon-dependent error
      const pred2 = act2.map(a => {
        const factor = H / 7;
        const n = (rng4() - 0.5) * 2 * factor * noise * 0.6;
        const d = factor * trend * 0.15 * (rng4() - 0.4);
        return a + n + d;
      });

      // Compute MAPEx using daily versions (rolling window)
      let totalTAE = 0;
      let totalActuals = 0;
      const maxVersion = N2 - H; // last version where bucket completes

      for (let vi = 0; vi < maxVersion; vi++) {
        let versionTAE = 0;
        let versionActuals = 0;
        for (let d = vi; d < vi + H; d++) {
          versionTAE += Math.abs(pred2[d] - act2[d]);
          versionActuals += act2[d];
        }
        totalTAE += versionTAE;
        totalActuals += versionActuals;
      }

      const mape = (totalActuals > 0) ? (totalTAE / totalActuals) * 100 : 0;
      return { horizon: H, mape };
    });
  }

  function renderMAPExChart() {
    const container = d3.select("#mapex-chart");
    container.selectAll("*").remove();

    const noise = +d3.select("#noise-slider").property("value");
    const trend = +d3.select("#trend-slider").property("value");
    d3.select("#noise-value").text(noise);
    d3.select("#trend-value").text(trend);

    const mapexData = computeMapexData(noise, trend);

    const cw = container.node().getBoundingClientRect().width;
    const width = cw;
    const height = Math.min(360, cw * 0.55);
    const iw = width - mapexMargin.left - mapexMargin.right;
    const ih = height - mapexMargin.top - mapexMargin.bottom;

    // Compute yMax accounting for both current and ghost data
    let allMapes = mapexData.map(d => d.mape);
    if (previousMapexData) allMapes = allMapes.concat(previousMapexData.map(d => d.mape));
    const yMax = d3.max(allMapes) * 1.15;

    const svg = container.append("svg")
      .attr("viewBox", `0 0 ${width} ${height}`)
      .attr("preserveAspectRatio", "xMidYMid meet");

    const g = svg.append("g").attr("transform", `translate(${mapexMargin.left},${mapexMargin.top})`);

    const x = d3.scaleBand().domain(HORIZONS).range([0, iw]).padding(0.25);
    const y = d3.scaleLinear().domain([0, yMax]).range([ih, 0]);

    const colorScale = d3.scaleSequential()
      .domain([0, yMax])
      .interpolator(d3.interpolateRgb(accent, orange));

    // Axes
    g.append("g").attr("transform", `translate(0,${ih})`)
      .call(d3.axisBottom(x).tickFormat(d => d + "d"))
      .call(g => g.select(".domain").attr("stroke", border))
      .call(g => g.selectAll(".tick line").attr("stroke", border))
      .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.65rem"));

    g.append("text").attr("x", iw / 2).attr("y", ih + 35)
      .attr("text-anchor", "middle").attr("fill", textMuted)
      .style("font-size", "0.72rem").text("Forecast Horizon (days)");

    g.append("g")
      .call(d3.axisLeft(y).ticks(6).tickFormat(d => d.toFixed(0) + "%"))
      .call(g => g.select(".domain").attr("stroke", border))
      .call(g => g.selectAll(".tick line").attr("stroke", border))
      .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.65rem"));

    g.append("text").attr("transform", "rotate(-90)")
      .attr("x", -ih / 2).attr("y", -42)
      .attr("text-anchor", "middle").attr("fill", textMuted)
      .style("font-size", "0.72rem").text("MAPE (%)");

    // Grid
    g.append("g")
      .call(d3.axisLeft(y).ticks(6).tickSize(-iw).tickFormat(""))
      .call(g => g.select(".domain").remove())
      .call(g => g.selectAll(".tick line").attr("stroke", border).attr("stroke-opacity", 0.5));

    // Ghost bars (previous state)
    if (previousMapexData) {
      g.selectAll(".ghost-bar")
        .data(previousMapexData)
        .enter()
        .append("rect")
        .attr("class", "ghost-bar")
        .attr("x", d => x(d.horizon))
        .attr("width", x.bandwidth())
        .attr("y", d => y(d.mape))
        .attr("height", d => ih - y(d.mape))
        .attr("rx", 4)
        .attr("fill", ghost)
        .attr("opacity", 0.5);

      // Ghost trend line
      const ghostLine = previousMapexData.map(d => [x(d.horizon) + x.bandwidth() / 2, y(d.mape)]);
      g.append("path").datum(ghostLine)
        .attr("d", d3.line().curve(d3.curveMonotoneX))
        .attr("fill", "none").attr("stroke", ghost)
        .attr("stroke-width", 2).attr("stroke-dasharray", "3 4").attr("opacity", 0.6);
    }

    // Current bars
    g.selectAll(".horizon-bar")
      .data(mapexData)
      .enter()
      .append("rect")
      .attr("class", "horizon-bar")
      .attr("x", d => x(d.horizon))
      .attr("width", x.bandwidth())
      .attr("y", ih).attr("height", 0)
      .attr("rx", 4)
      .attr("fill", d => colorScale(d.mape))
      .on("mouseover", function (evt, d) {
        d3.select(this).attr("opacity", 0.8);
        let ttHtml = `Horizon: ${d.horizon} days<br>MAPE: ${d.mape.toFixed(2)}%`;
        if (previousMapexData) {
          const prev = previousMapexData.find(p => p.horizon === d.horizon);
          if (prev) ttHtml += `<br><span style="color:${ghost}">Previous: ${prev.mape.toFixed(2)}%</span>`;
        }
        showTooltip(evt, ttHtml);
      })
      .on("mousemove", function (evt) { showTooltip(evt, tooltip.html()); })
      .on("mouseout", function () { d3.select(this).attr("opacity", 1); hideTooltip(); })
      .transition().duration(600).delay((d, i) => i * 50)
      .attr("y", d => y(d.mape))
      .attr("height", d => ih - y(d.mape));

    // Value labels
    g.selectAll(".bar-label")
      .data(mapexData)
      .enter()
      .append("text")
      .attr("x", d => x(d.horizon) + x.bandwidth() / 2)
      .attr("y", d => y(d.mape) - 6)
      .attr("text-anchor", "middle").attr("fill", textMuted)
      .style("font-size", "0.6rem").style("font-family", "var(--mono)")
      .style("opacity", 0).text(d => d.mape.toFixed(1) + "%")
      .transition().duration(600).delay((d, i) => i * 50 + 300)
      .style("opacity", 1);

    // Trend line
    const lineData = mapexData.map(d => [x(d.horizon) + x.bandwidth() / 2, y(d.mape)]);
    g.append("path").datum(lineData)
      .attr("d", d3.line().curve(d3.curveMonotoneX))
      .attr("fill", "none").attr("stroke", accent)
      .attr("stroke-width", 2).attr("stroke-dasharray", "4 3").attr("opacity", 0.5);

    // Store current as ghost for next render
    previousMapexData = mapexData;
  }

  renderMAPExChart();
  d3.select("#noise-slider").on("input", renderMAPExChart);
  d3.select("#trend-slider").on("input", renderMAPExChart);

  /* ═══════════════════════════════════════
     3b) Daily Versions Demo
     ═══════════════════════════════════════ */
  const dailyMargin = { top: 20, right: 30, bottom: 50, left: 60 };

  function renderDailyVersionsChart() {
    const container = d3.select("#daily-versions-chart");
    container.selectAll("*").remove();

    const H = +d3.select("#daily-horizon-select").property("value");
    const versionIdx = +d3.select("#version-slider").property("value");

    // Generate 50 days of synthetic data starting Jan 1, 2026
    const startDate = new Date(2026, 0, 1);
    const nDays = 50;
    const rngDaily = seededRandom(555);
    const dailyActuals = [];
    const dailyForecasts = [];
    let dv = 100;

    for (let i = 0; i < nDays; i++) {
      dv += (rngDaily() - 0.48) * 6 + 0.5;
      dv = Math.max(dv, 40);
      const actual = Math.round(dv * 10) / 10;
      dailyActuals.push(actual);
      const horizonFactor = H / 7;
      const forecast = actual + (rngDaily() - 0.5) * 10 * horizonFactor;
      dailyForecasts.push(Math.round(forecast * 10) / 10);
    }

    // Today = Feb 16 = day index 46
    const todayIdx = 46;
    const maxVersionIdx = todayIdx - H + 1;
    const versions = [];
    for (let vi = Math.max(0, maxVersionIdx - 15); vi <= maxVersionIdx; vi++) {
      versions.push(vi);
    }

    d3.select("#version-slider").attr("max", versions.length - 1);
    const clampedIdx = Math.min(versionIdx, versions.length - 1);
    const currentVersionIdx = versions[clampedIdx];
    const versionDate = new Date(startDate.getTime() + currentVersionIdx * 86400000);
    const dvFmt = d3.timeFormat("%b %d");
    d3.select("#version-date-display").text(dvFmt(versionDate));

    // Compute TAE and Actuals for this version's bucket
    let tae = 0;
    let actualsSum = 0;
    for (let d = currentVersionIdx; d < currentVersionIdx + H && d < nDays; d++) {
      tae += Math.abs(dailyForecasts[d] - dailyActuals[d]);
      actualsSum += dailyActuals[d];
    }
    const versionMAPE = actualsSum > 0 ? (tae / actualsSum) * 100 : 0;
    const bucketEndDate = new Date(versionDate.getTime() + (H - 1) * 86400000);

    d3.select("#version-stats").html(
      "<strong>Version " + dvFmt(versionDate) + ":</strong> Bucket [" + dvFmt(versionDate) + " \u2013 " + dvFmt(bucketEndDate) + "]<br>" +
      "TAE = " + tae.toFixed(1) + ", Actuals = " + actualsSum.toFixed(1) + ", MAPE = " + versionMAPE.toFixed(2) + "%"
    );

    // Draw chart with bucket highlighted
    const cw = container.node().getBoundingClientRect().width;
    const width = cw;
    const height = Math.min(300, cw * 0.45);
    const iw = width - dailyMargin.left - dailyMargin.right;
    const ih = height - dailyMargin.top - dailyMargin.bottom;

    const svg = container.append("svg")
      .attr("viewBox", "0 0 " + width + " " + height)
      .attr("preserveAspectRatio", "xMidYMid meet");

    const gd = svg.append("g").attr("transform", "translate(" + dailyMargin.left + "," + dailyMargin.top + ")");

    const dates = d3.range(nDays).map(i => new Date(startDate.getTime() + i * 86400000));
    const xd = d3.scaleTime().domain([dates[0], dates[nDays - 1]]).range([0, iw]);
    const yd = d3.scaleLinear().domain([30, d3.max(dailyActuals) + 10]).range([ih, 0]);

    // Highlight bucket region
    const bucketStart = dates[currentVersionIdx];
    const bucketEnd = dates[Math.min(currentVersionIdx + H - 1, nDays - 1)];
    gd.append("rect")
      .attr("x", xd(bucketStart))
      .attr("y", 0)
      .attr("width", xd(bucketEnd) - xd(bucketStart))
      .attr("height", ih)
      .attr("fill", "rgba(109,40,217,0.08)")
      .attr("stroke", accent)
      .attr("stroke-width", 1.5)
      .attr("stroke-dasharray", "4 3");

    // Axes
    gd.append("g").attr("transform", "translate(0," + ih + ")")
      .call(d3.axisBottom(xd).ticks(8).tickFormat(d3.timeFormat("%b %d")))
      .call(g => g.select(".domain").attr("stroke", border))
      .call(g => g.selectAll(".tick line").attr("stroke", border))
      .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.6rem"));

    gd.append("g")
      .call(d3.axisLeft(yd).ticks(5))
      .call(g => g.select(".domain").attr("stroke", border))
      .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.65rem"));

    // Grid
    gd.append("g")
      .call(d3.axisLeft(yd).ticks(5).tickSize(-iw).tickFormat(""))
      .call(g => g.select(".domain").remove())
      .call(g => g.selectAll(".tick line").attr("stroke", border).attr("stroke-opacity", 0.4));

    // Lines
    const dvLine = d3.line().x(function(d, i) { return xd(dates[i]); }).y(function(d) { return yd(d); }).curve(d3.curveMonotoneX);

    gd.append("path").datum(dailyActuals).attr("d", dvLine)
      .attr("fill", "none").attr("stroke", teal).attr("stroke-width", 2);

    gd.append("path").datum(dailyForecasts).attr("d", dvLine)
      .attr("fill", "none").attr("stroke", orange).attr("stroke-width", 1.5).attr("stroke-dasharray", "4 2");

    // Version date marker
    gd.append("line")
      .attr("x1", xd(versionDate)).attr("x2", xd(versionDate))
      .attr("y1", 0).attr("y2", ih)
      .attr("stroke", accent).attr("stroke-width", 2);

    gd.append("text")
      .attr("x", xd(versionDate))
      .attr("y", -5)
      .attr("text-anchor", "middle")
      .attr("fill", accent)
      .style("font-size", "0.7rem")
      .style("font-weight", "600")
      .text("Version Date");

    // Today marker
    if (todayIdx < nDays) {
      gd.append("line")
        .attr("x1", xd(dates[todayIdx])).attr("x2", xd(dates[todayIdx]))
        .attr("y1", 0).attr("y2", ih)
        .attr("stroke", red).attr("stroke-width", 1).attr("stroke-dasharray", "3 3");

      gd.append("text")
        .attr("x", xd(dates[todayIdx])).attr("y", -5)
        .attr("text-anchor", "middle").attr("fill", red)
        .style("font-size", "0.65rem").style("font-weight", "600")
        .text("Today");
    }
  }

  renderDailyVersionsChart();
  d3.select("#daily-horizon-select").on("change", renderDailyVersionsChart);
  d3.select("#version-slider").on("input", renderDailyVersionsChart);

  /* ═══════════════════════════════════════
     3c) Forecast Revision Impact Grid
     ═══════════════════════════════════════ */
  function renderImpactGrid() {
    const tbody = d3.select("#impact-body");
    tbody.selectAll("*").remove();

    const weeks = ["Week 1", "Week 2", "Week 3", "Week 4"];
    const horizons = [7, 14, 21, 28, 35];

    const impactMap = {
      "Week 1": { 7: "M", 14: "M", 21: "M", 28: "M+1", 35: "M+1" },
      "Week 2": { 7: "M", 14: "M", 21: "M, M+1", 28: "M+1", 35: "M+1, M+2" },
      "Week 3": { 7: "M", 14: "M", 21: "M+1", 28: "M+1", 35: "M+2" },
      "Week 4": { 7: "M", 14: "M, M+1", 21: "M+1", 28: "M+1", 35: "M+2" }
    };

    weeks.forEach(function(week) {
      const tr = tbody.append("tr");
      tr.append("td").text(week).style("font-weight", "600");

      horizons.forEach(function(h) {
        const impact = impactMap[week][h];
        const td = tr.append("td").text(impact);

        if (impact === "M") td.attr("class", "current-month");
        else if (impact.indexOf(",") >= 0) td.attr("class", "both-months");
        else td.attr("class", "next-month");

        td.on("click", function() {
          const rngImpact = seededRandom(week.charCodeAt(5) * 100 + h);
          const improvement = (rngImpact() * 3 + 1).toFixed(2);
          d3.select("#impact-result")
            .style("display", "block")
            .html("<strong>Editing " + week + " forecasts improves H=" + h + " MAPE by " + improvement + "%</strong><br>" +
                  "<span style=\"font-size:0.8rem;\">Affected periods: " + impact + "</span>");
        });
      });
    });
  }

  renderImpactGrid();

  /* ═══════════════════════════════════════
     4) Benchmark / Interpretation Chart
     ═══════════════════════════════════════ */
  (function () {
    const benchmarks = [
      { label: "Excellent", range: "< 10%", lo: 0, hi: 10, color: "#16a34a" },
      { label: "Good", range: "10–20%", lo: 10, hi: 20, color: "#65a30d" },
      { label: "Reasonable", range: "20–30%", lo: 20, hi: 30, color: "#eab308" },
      { label: "Poor", range: "30–50%", lo: 30, hi: 50, color: "#f97316" },
      { label: "Inaccurate", range: "> 50%", lo: 50, hi: 70, color: "#dc2626" },
    ];

    const container = d3.select("#benchmark-chart");
    const cw = container.node().getBoundingClientRect().width;
    const width = cw;
    const height = 180;
    const margin = { top: 15, right: 20, bottom: 30, left: 90 };
    const iw = width - margin.left - margin.right;
    const ih = height - margin.top - margin.bottom;

    const svg = container.append("svg")
      .attr("viewBox", `0 0 ${width} ${height}`)
      .attr("preserveAspectRatio", "xMidYMid meet");

    const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

    const y = d3.scaleBand().domain(benchmarks.map(d => d.label)).range([0, ih]).padding(0.3);
    const x = d3.scaleLinear().domain([0, 70]).range([0, iw]);

    g.append("g")
      .call(d3.axisBottom(x).ticks(7).tickFormat(d => d + "%"))
      .attr("transform", `translate(0,${ih})`)
      .call(g => g.select(".domain").attr("stroke", border))
      .call(g => g.selectAll(".tick line").attr("stroke", border))
      .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.65rem"));

    g.append("g")
      .call(d3.axisLeft(y))
      .call(g => g.select(".domain").remove())
      .call(g => g.selectAll(".tick line").remove())
      .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.72rem").style("font-weight", "600"));

    g.selectAll(".bench-bar").data(benchmarks).enter()
      .append("rect")
      .attr("x", d => x(d.lo)).attr("y", d => y(d.label))
      .attr("width", 0).attr("height", y.bandwidth())
      .attr("rx", 4).attr("fill", d => d.color).attr("opacity", 0.8)
      .transition().duration(700).delay((d, i) => i * 80)
      .attr("width", d => x(d.hi) - x(d.lo));

    g.selectAll(".bench-label").data(benchmarks).enter()
      .append("text")
      .attr("x", d => x(d.hi) + 6)
      .attr("y", d => y(d.label) + y.bandwidth() / 2)
      .attr("dy", "0.35em").attr("fill", textMuted)
      .style("font-size", "0.65rem").style("font-family", "var(--mono)")
      .text(d => d.range);
  })();

  /* ═══════════════════════════════════════
     5) CSV Upload — custom MAPEx
     ═══════════════════════════════════════ */
  function parseCSV(text) {
    const lines = text.trim().split(/\r?\n/);
    if (lines.length < 2) return null;
    const headers = lines[0].toLowerCase().split(",").map(h => h.trim());
    const ai = headers.indexOf("actual");
    const fi = headers.indexOf("forecast");
    const hi = headers.indexOf("horizon");
    if (ai === -1 || fi === -1) return null;

    const rows = [];
    for (let i = 1; i < lines.length; i++) {
      const cols = lines[i].split(",").map(c => c.trim());
      if (!cols[ai] || !cols[fi]) continue;
      const row = { actual: +cols[ai], forecast: +cols[fi] };
      if (hi !== -1 && cols[hi]) row.horizon = +cols[hi];
      if (!isNaN(row.actual) && !isNaN(row.forecast)) rows.push(row);
    }
    return rows.length > 0 ? rows : null;
  }

  function renderCSVResult(rows) {
    const resultDiv = d3.select("#csv-result");
    resultDiv.style("display", "block");
    d3.select("#csv-mapex-chart").selectAll("*").remove();

    const hasHorizon = rows[0].horizon !== undefined;

    if (hasHorizon) {
      // Group by horizon and compute MAPE for each
      const grouped = d3.group(rows, d => d.horizon);
      const mapexData = [];
      grouped.forEach((vals, h) => {
        const act = vals.map(v => v.actual);
        const pred = vals.map(v => v.forecast);
        mapexData.push({ horizon: h, mape: computeMAPE(act, pred) });
      });
      mapexData.sort((a, b) => a.horizon - b.horizon);

      const overallAct = rows.map(r => r.actual);
      const overallPred = rows.map(r => r.forecast);
      const overallMape = computeMAPE(overallAct, overallPred);
      d3.select("#csv-mape-result").text("Overall MAPE = " + overallMape.toFixed(2) + "%");

      // Draw MAPEx bar chart
      const container = d3.select("#csv-mapex-chart");
      const cw = container.node().getBoundingClientRect().width;
      const width = cw;
      const height = Math.min(300, cw * 0.5);
      const margin = { top: 20, right: 20, bottom: 40, left: 55 };
      const iw = width - margin.left - margin.right;
      const ih = height - margin.top - margin.bottom;

      const svg = container.append("svg")
        .attr("viewBox", `0 0 ${width} ${height}`)
        .attr("preserveAspectRatio", "xMidYMid meet");

      const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

      const x = d3.scaleBand().domain(mapexData.map(d => d.horizon)).range([0, iw]).padding(0.35);
      const yMax = d3.max(mapexData, d => d.mape) * 1.15;
      const y = d3.scaleLinear().domain([0, yMax]).range([ih, 0]);

      const colorScale = d3.scaleSequential()
        .domain([0, yMax]).interpolator(d3.interpolateRgb(accent, orange));

      g.append("g").attr("transform", `translate(0,${ih})`)
        .call(d3.axisBottom(x).tickFormat(d => d + "d"))
        .call(g => g.select(".domain").attr("stroke", border))
        .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.65rem"));

      g.append("g")
        .call(d3.axisLeft(y).ticks(5).tickFormat(d => d.toFixed(0) + "%"))
        .call(g => g.select(".domain").attr("stroke", border))
        .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.65rem"));

      g.append("g")
        .call(d3.axisLeft(y).ticks(5).tickSize(-iw).tickFormat(""))
        .call(g => g.select(".domain").remove())
        .call(g => g.selectAll(".tick line").attr("stroke", border).attr("stroke-opacity", 0.5));

      g.selectAll(".csv-bar").data(mapexData).enter()
        .append("rect")
        .attr("x", d => x(d.horizon)).attr("width", x.bandwidth())
        .attr("y", ih).attr("height", 0).attr("rx", 4)
        .attr("fill", d => colorScale(d.mape))
        .on("mouseover", function(evt, d) {
          showTooltip(evt, `Horizon: ${d.horizon} days<br>MAPE: ${d.mape.toFixed(2)}%`);
        })
        .on("mouseout", hideTooltip)
        .transition().duration(600).delay((d, i) => i * 60)
        .attr("y", d => y(d.mape)).attr("height", d => ih - y(d.mape));

      g.selectAll(".csv-label").data(mapexData).enter()
        .append("text")
        .attr("x", d => x(d.horizon) + x.bandwidth() / 2)
        .attr("y", d => y(d.mape) - 6)
        .attr("text-anchor", "middle").attr("fill", textMuted)
        .style("font-size", "0.6rem").style("font-family", "var(--mono)")
        .text(d => d.mape.toFixed(1) + "%");

    } else {
      // No horizon column — just show overall MAPE
      const act = rows.map(r => r.actual);
      const pred = rows.map(r => r.forecast);
      const mape = computeMAPE(act, pred);
      d3.select("#csv-mape-result").text("MAPE = " + mape.toFixed(2) + "% (" + rows.length + " rows)");
      d3.select("#csv-mapex-chart").append("p")
        .attr("class", "muted")
        .style("text-align", "center").style("font-size", "0.82rem")
        .text("Add a \"horizon\" column (e.g. 7, 14, 21, 28, 35) to see a MAPEx curve.");
    }
  }

  // File upload handler
  d3.select("#csv-upload").on("change", function () {
    const file = this.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function (e) {
      const rows = parseCSV(e.target.result);
      if (!rows) {
        d3.select("#csv-status").text("Could not parse CSV. Ensure it has \"actual\" and \"forecast\" columns.");
        d3.select("#csv-result").style("display", "none");
        return;
      }
      d3.select("#csv-status").text("Loaded " + rows.length + " rows from " + file.name);
      renderCSVResult(rows);
    };
    reader.readAsText(file);
  });

  // Sample data button
  d3.select("#csv-sample-btn").on("click", function () {
    const sampleCSV = [
      "actual,forecast,horizon",
      "100,97,7", "120,115,7", "90,88,7", "110,108,7", "105,101,7",
      "100,92,14", "120,110,14", "90,82,14", "110,100,14", "105,95,14",
      "100,88,21", "120,105,21", "90,78,21", "110,95,21", "105,90,21",
      "100,82,28", "120,98,28", "90,72,28", "110,88,28", "105,84,28",
      "100,75,35", "120,92,35", "90,68,35", "110,82,35", "105,78,35"
    ].join("\n");
    const rows = parseCSV(sampleCSV);
    d3.select("#csv-status").text("Loaded sample data (25 rows across 5 horizons)");
    renderCSVResult(rows);
  });

  /* ═══════════════════════════════════════
     6) Horizon Lag Visualization
     ═══════════════════════════════════════ */
  (function () {
    const container = d3.select("#lag-chart");
    const cw = container.node().getBoundingClientRect().width;
    const width = cw;
    const height = Math.min(320, cw * 0.5);
    const margin = { top: 25, right: 30, bottom: 35, left: 55 };
    const iw = width - margin.left - margin.right;
    const ih = height - margin.top - margin.bottom;

    const svg = container.append("svg")
      .attr("viewBox", `0 0 ${width} ${height}`)
      .attr("preserveAspectRatio", "xMidYMid meet");

    const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

    // Generate a synthetic daily series (50 days)
    const rngL = seededRandom(99);
    const nDays = 50;
    const series = [];
    let sv = 100;
    for (let i = 0; i < nDays; i++) {
      sv += (rngL() - 0.48) * 5 + 0.2;
      sv = Math.max(sv, 30);
      series.push(sv);
    }

    const today = 25; // "today" marker
    const x = d3.scaleLinear().domain([0, nDays - 1]).range([0, iw]);
    const y = d3.scaleLinear().domain([d3.min(series) - 5, d3.max(series) + 10]).range([ih, 0]);

    // X axis
    g.append("g").attr("transform", `translate(0,${ih})`)
      .call(d3.axisBottom(x).ticks(10).tickFormat(d => "d" + (d + 1)))
      .call(g => g.select(".domain").attr("stroke", border))
      .call(g => g.selectAll(".tick line").attr("stroke", border))
      .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.6rem"));

    // Y axis
    g.append("g")
      .call(d3.axisLeft(y).ticks(5))
      .call(g => g.select(".domain").attr("stroke", border))
      .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.6rem"));

    // Grid
    g.append("g")
      .call(d3.axisLeft(y).ticks(5).tickSize(-iw).tickFormat(""))
      .call(g => g.select(".domain").remove())
      .call(g => g.selectAll(".tick line").attr("stroke", border).attr("stroke-opacity", 0.4));

    // Known data (up to "today")
    const knownData = series.slice(0, today + 1);
    const lineGen = d3.line().x((d, i) => x(i)).y(d => y(d)).curve(d3.curveMonotoneX);

    g.append("path").datum(knownData).attr("d", lineGen)
      .attr("fill", "none").attr("stroke", teal).attr("stroke-width", 2.5);

    // "Today" vertical line
    g.append("line")
      .attr("x1", x(today)).attr("x2", x(today))
      .attr("y1", 0).attr("y2", ih)
      .attr("stroke", accent).attr("stroke-width", 1.5).attr("stroke-dasharray", "4 3");

    g.append("text")
      .attr("x", x(today)).attr("y", -8)
      .attr("text-anchor", "middle").attr("fill", accent)
      .style("font-size", "0.7rem").style("font-weight", "600").text("Today");

    // For each horizon, draw the lag gap and prediction point
    const horizonColors = ["#16a34a", "#2563eb", "#8b5cf6", "#ea580c", "#dc2626"];

    HORIZONS.forEach((h, idx) => {
      const targetDay = today + Math.round(h * nDays / 50); // scale to series
      if (targetDay >= nDays) return;

      const yRow = ih - 12 - idx * (ih / 6.5); // stagger vertically for labels
      const targetVal = series[targetDay];
      const color = horizonColors[idx];

      // Lag arrow (horizontal bracket)
      const x1 = x(today);
      const x2 = x(targetDay);
      const arrowY = y(targetVal);

      // Dashed lag line
      g.append("line")
        .attr("x1", x1).attr("x2", x2)
        .attr("y1", arrowY).attr("y2", arrowY)
        .attr("stroke", color).attr("stroke-width", 1.5)
        .attr("stroke-dasharray", "3 3").attr("opacity", 0.7);

      // Prediction target dot
      g.append("circle")
        .attr("cx", x2).attr("cy", arrowY)
        .attr("r", 5).attr("fill", color).attr("stroke", "#fff").attr("stroke-width", 1.5);

      // Future series (faded)
      const futureSlice = series.slice(today, targetDay + 1);
      const futureLine = d3.line()
        .x((d, i) => x(today + i)).y(d => y(d)).curve(d3.curveMonotoneX);

      g.append("path").datum(futureSlice).attr("d", futureLine)
        .attr("fill", "none").attr("stroke", color)
        .attr("stroke-width", 1).attr("stroke-dasharray", "2 3").attr("opacity", 0.35);

      // Horizon label
      g.append("text")
        .attr("x", x2 + 6).attr("y", arrowY + 4)
        .attr("fill", color).style("font-size", "0.65rem").style("font-weight", "600")
        .text(h + "d");
    });

    // Shaded "known" region
    const knownArea = d3.area()
      .x((d, i) => x(i)).y0(ih).y1(d => y(d)).curve(d3.curveMonotoneX);

    g.insert("path", ":first-child").datum(knownData).attr("d", knownArea)
      .attr("fill", teal).attr("opacity", 0.06);

  })();

  /* ═══════════════════════════════════════
     7) Responsive resize
     ═══════════════════════════════════════ */
  let resizeTimer;
  window.addEventListener("resize", () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => {
      renderTSChart();
      previousMapexData = null; // reset ghost on resize
      renderMAPExChart();
      renderDailyVersionsChart();
    }, 200);
  });

  /* ═══════════════════════════════════════
     8) KaTeX Formula Rendering
     ═══════════════════════════════════════ */
  function renderKaTeX() {
    var mapeEl = document.getElementById('mape-formula');
    var mapexEl = document.getElementById('mapex-formula-daily');

    if (typeof katex !== 'undefined') {
      if (mapeEl) {
        katex.render(
          String.raw`\text{MAPE} = \frac{100\%}{n} \times \sum_{t=1}^{n} \frac{|A_t - F_t|}{|A_t|}`,
          mapeEl,
          { displayMode: true, throwOnError: false }
        );
      }
      if (mapexEl) {
        katex.render(
          String.raw`\text{MAPEx}_H = \frac{\displaystyle\sum_{\text{all versions}} \text{TAE}_v}{\displaystyle\sum_{\text{all versions}} \text{Actuals}_v}`,
          mapexEl,
          { displayMode: true, throwOnError: false }
        );
      }
    }
  }

  // Wait for KaTeX to load then render
  if (typeof katex !== 'undefined') {
    renderKaTeX();
  } else {
    var katexScript = document.querySelector('script[src*="katex"]');
    if (katexScript) {
      katexScript.addEventListener('load', renderKaTeX);
    }
    // Fallback: poll for katex
    var katexPoll = setInterval(function() {
      if (typeof katex !== 'undefined') {
        clearInterval(katexPoll);
        renderKaTeX();
      }
    }, 100);
    setTimeout(function() { clearInterval(katexPoll); }, 5000);
  }

  /* ═══════════════════════════════════════
     9) Intersection observer for animations
     ═══════════════════════════════════════ */
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        entry.target.style.opacity = "1";
        entry.target.style.transform = "translateY(0)";
      }
    });
  }, { threshold: 0.15 });

  document.querySelectorAll(".vis-card, .step-card, .callout, .formula-card").forEach(el => {
    el.style.opacity = "0";
    el.style.transform = "translateY(20px)";
    el.style.transition = "opacity 0.6s ease, transform 0.6s ease";
    observer.observe(el);
  });

})();
</script>
</body>
</html>
