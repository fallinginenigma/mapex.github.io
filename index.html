<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MAPEx Error Calculator — Understanding Mean Absolute Percentage Error Over Forecast Horizons</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,300;0,14..32,400;0,14..32,500;0,14..32,600;0,14..32,700;0,14..32,800;1,14..32,400&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
  <style>
    /* ── Reset & Base ── */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --bg: #F5F7FA;
      --text: #1B2A4A;
      --text-muted: #4A5C7A;
      --accent: #003DA5;
      --accent-light: #E6EBF7;
      --accent-mid: #4D79C0;
      --orange: #CC0000;
      --orange-light: #FDEAEA;
      --teal: #007B5F;
      --teal-light: #E6F2EF;
      --red: #CC0000;
      --blue: #0068B4;
      --green: #007B5F;
      --border: #D0D8E8;
      --card-bg: #ffffff;
      --code-bg: #EEF2F9;
      --serif: 'Source Serif 4', Georgia, serif;
      --sans: 'Inter', system-ui, -apple-system, sans-serif;
      --mono: 'Fira Code', 'SF Mono', monospace;
      --serif: 'Inter', system-ui, sans-serif;
      --max-w: 700px;
      --wide-max-w: 1280px;
    }

    html { scroll-behavior: smooth; font-size: 18px; }

    body {
      font-family: var(--sans);
      background: var(--bg);
      color: var(--text);
      line-height: 1.7;
      -webkit-font-smoothing: antialiased;
    }

    /* ── Hero ── */
    .hero {
      text-align: center;
      padding: 5rem 2rem 4rem;
      background: linear-gradient(180deg, var(--accent-light) 0%, var(--bg) 100%);
      border-bottom: 1px solid var(--border);
    }

    .hero-badge {
      display: inline-block;
      background: var(--accent);
      color: #fff;
      font-size: 0.7rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      padding: 0.3em 1em;
      border-radius: 100px;
      margin-bottom: 1.5rem;
    }

    .hero h1 {
      font-family: var(--sans);
      font-size: clamp(2.4rem, 6vw, 3.8rem);
      font-weight: 800;
      line-height: 1.1;
      letter-spacing: -0.03em;
      color: var(--text);
      max-width: 800px;
      margin: 0 auto 1rem;
    }

    .hero h1 span { color: var(--accent); }

    .hero p {
      font-size: 1.15rem;
      color: var(--text-muted);
      max-width: 560px;
      margin: 0 auto;
      line-height: 1.6;
    }

    /* ── Article body ── */
    .article { max-width: var(--wide-max-w); margin: 0 auto; padding: 3rem 2.5rem 5rem; }

    .article h2 {
      font-family: var(--sans);
      font-size: clamp(1.45rem, 2.2vw, 1.85rem);
      font-weight: 700;
      letter-spacing: -0.02em;
      margin: 3.5rem 0 1rem;
      color: var(--text);
    }

    .article h3 {
      font-family: var(--sans);
      font-size: 1.2rem;
      font-weight: 600;
      letter-spacing: -0.01em;
      margin: 2rem 0 0.65rem;
    }

    .article p { margin-bottom: 1.25rem; color: var(--text); }
    .article p.muted { color: var(--text-muted); font-size: 0.95rem; }

    .article a { color: var(--accent); text-decoration: underline; text-underline-offset: 2px; }
    .article a:hover { color: var(--orange); }

    .highlight { color: var(--accent); font-weight: 600; }
    .highlight-orange { color: var(--orange); font-weight: 600; }
    .highlight-teal { color: var(--teal); font-weight: 600; }

    /* ── Formula card ── */
    .formula-card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 2rem;
      margin: 1.5rem 0 2rem;
      text-align: center;
      box-shadow: 0 1px 3px rgba(0,0,0,0.04);
    }

    .formula-card .formula {
      font-family: var(--mono);
      font-size: 1.1rem;
      line-height: 2;
      color: var(--text);
    }

    .formula .f-var { color: var(--accent); font-weight: 500; }
    .formula .f-actual { color: var(--teal); font-weight: 500; }
    .formula .f-pred { color: var(--orange); font-weight: 500; }
    .formula .f-op { color: var(--text-muted); }

    .formula-card .formula-label {
      display: block;
      margin-top: 0.75rem;
      font-size: 0.8rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    /* ── Visualization containers ── */
    .vis-wide {
      max-width: var(--wide-max-w);
      margin: 2rem auto;
      padding: 0 1.5rem;
    }

    .vis-card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1.5rem 1.5rem 1rem;
      margin: 2rem 0;
      box-shadow: 0 1px 3px rgba(0,0,0,0.04);
      overflow: hidden;
    }

    .vis-card h4 {
      font-family: var(--sans);
      font-size: 0.8rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
      margin-bottom: 1rem;
    }

    .vis-card svg { display: block; width: 100%; height: auto; }

    /* ── Interactive controls ── */
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 1.25rem;
      align-items: center;
      margin-bottom: 1.25rem;
      padding: 1rem 1.25rem;
      background: var(--code-bg);
      border-radius: 8px;
    }

    .control-group { display: flex; flex-direction: column; gap: 0.3rem; }

    .control-group label {
      font-size: 0.72rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
    }

    .control-group .value-display {
      font-family: var(--mono);
      font-size: 0.85rem;
      font-weight: 500;
      color: var(--accent);
      min-width: 3ch;
    }

    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 180px;
      height: 6px;
      border-radius: 3px;
      background: var(--border);
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px; height: 18px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      border: 2px solid #fff;
      box-shadow: 0 1px 4px rgba(0,0,0,0.2);
      transition: transform 0.12s ease, box-shadow 0.12s ease;
    }

    input[type="range"]::-webkit-slider-thumb:active {
      transform: scale(1.25);
      box-shadow: 0 2px 8px rgba(0,61,165,0.35);
    }

    input[type="range"]::-moz-range-thumb {
      width: 18px; height: 18px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      border: 2px solid #fff;
      box-shadow: 0 1px 4px rgba(0,0,0,0.2);
      transition: transform 0.12s ease, box-shadow 0.12s ease;
    }

    input[type="range"]::-moz-range-thumb:active {
      transform: scale(1.25);
      box-shadow: 0 2px 8px rgba(0,61,165,0.35);
    }

    /* ── Callout boxes ── */
    .callout {
      border-left: 4px solid var(--accent);
      background: var(--accent-light);
      padding: 1rem 1.25rem;
      border-radius: 0 8px 8px 0;
      margin: 1.5rem 0;
      font-size: 0.95rem;
    }

    .callout.callout-orange {
      border-left-color: var(--orange);
      background: var(--orange-light);
    }

    .callout.callout-teal {
      border-left-color: var(--teal);
      background: var(--teal-light);
    }

    .callout strong { font-weight: 700; }

    /* ── Step-through / scrollytelling ── */
    .step-cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin: 1.5rem 0 2rem;
    }

    .step-card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 1.25rem;
      text-align: center;
      transition: border-color 0.2s, box-shadow 0.2s;
    }

    .step-card:hover {
      border-color: var(--accent-mid);
      box-shadow: 0 2px 8px rgba(0,61,165,0.08);
    }

    .step-card .step-num {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 2rem; height: 2rem;
      border-radius: 50%;
      background: var(--accent);
      color: #fff;
      font-size: 0.8rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
    }

    .step-card h5 {
      font-size: 0.95rem;
      font-weight: 600;
      margin-bottom: 0.35rem;
    }

    .step-card p {
      font-size: 0.82rem;
      color: var(--text-muted);
      margin: 0;
      line-height: 1.5;
    }

    /* ── Table for MAPE calculation ── */
    .calc-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
      margin: 1rem 0;
    }

    .calc-table th {
      background: var(--code-bg);
      font-weight: 600;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--text-muted);
      padding: 0.6rem 0.75rem;
      text-align: center;
      border-bottom: 2px solid var(--border);
    }

    .calc-table td {
      padding: 0.55rem 0.75rem;
      text-align: center;
      border-bottom: 1px solid var(--border);
      font-family: var(--mono);
      font-size: 0.85rem;
    }

    .calc-table tr:last-child td { border-bottom: none; }
    .calc-table .col-actual { color: var(--teal); font-weight: 500; }
    .calc-table .col-pred { color: var(--orange); font-weight: 500; }
    .calc-table .col-error { color: var(--red); font-weight: 500; }

    .mape-result {
      text-align: center;
      font-family: var(--mono);
      font-size: 1.4rem;
      font-weight: 700;
      color: var(--accent);
      padding: 0.75rem;
      background: var(--accent-light);
      border-radius: 8px;
      margin: 1rem 0;
    }

    /* ── Horizon bar chart colors ── */
    .horizon-bar { transition: all 0.3s ease; }
    .horizon-bar:hover { opacity: 0.85; }

    /* ── Tooltip ── */
    .tooltip {
      position: absolute;
      pointer-events: none;
      background: var(--text);
      color: #fff;
      padding: 0.4rem 0.65rem;
      border-radius: 6px;
      font-size: 0.78rem;
      font-family: var(--mono);
      line-height: 1.4;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      opacity: 0;
      transition: opacity 0.15s;
      z-index: 100;
      white-space: nowrap;
    }

    /* ── Legend ── */
    .legend {
      display: flex;
      gap: 1.5rem;
      flex-wrap: wrap;
      margin-bottom: 0.75rem;
      font-size: 0.8rem;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      color: var(--text-muted);
    }

    .legend-swatch {
      width: 12px; height: 12px;
      border-radius: 3px;
      flex-shrink: 0;
    }

    /* ── Animated dot ── */
    @keyframes pulse {
      0%, 100% { r: 4; opacity: 1; }
      50% { r: 7; opacity: 0.6; }
    }

    .pulse-dot { animation: pulse 2s ease-in-out infinite; }

    /* ── Divider ── */
    .divider {
      border: none;
      height: 1px;
      background: var(--border);
      margin: 3rem 0;
    }

    /* ── Footer ── */
    .footer {
      text-align: center;
      padding: 2.5rem 1.5rem;
      border-top: 1px solid var(--border);
      color: var(--text-muted);
      font-size: 0.82rem;
    }

    .footer a { color: var(--accent); text-decoration: none; }
    .footer a:hover { text-decoration: underline; }

    /* ── Impact table ── */
    .impact-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
      margin: 1rem 0;
    }

    .impact-table th {
      background: var(--code-bg);
      font-weight: 600;
      font-size: 0.7rem;
      text-transform: uppercase;
      padding: 0.6rem 0.5rem;
      text-align: center;
      border: 1px solid var(--border);
    }

    .impact-table td {
      padding: 0.75rem 0.5rem;
      text-align: center;
      border: 1px solid var(--border);
      cursor: pointer;
      transition: background 0.2s;
    }

    .impact-table td:hover {
      background: var(--accent-light);
    }

    .impact-table td.current-month {
      background: var(--teal-light);
      color: var(--teal);
      font-weight: 600;
    }

    .impact-table td.next-month {
      background: var(--orange-light);
      color: var(--orange);
      font-weight: 600;
    }

    .impact-table td.both-months {
      background: linear-gradient(135deg, var(--teal-light) 50%, var(--orange-light) 50%);
      color: var(--text);
      font-weight: 600;
    }

    /* ── Scenario toggle buttons ── */
    .scenario-btns {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
    }

    .scenario-btn {
      font-family: var(--sans);
      font-size: 0.75rem;
      font-weight: 600;
      padding: 0.45em 1em;
      border-radius: 100px;
      border: 1.5px solid var(--border);
      background: var(--card-bg);
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.2s;
    }

    .scenario-btn:hover { border-color: var(--accent-mid); color: var(--accent); }
    .scenario-btn.active { background: var(--accent); color: #fff; border-color: var(--accent); }

    /* ── Play button ── */
    .play-btn {
      font-family: var(--sans);
      font-size: 0.75rem;
      font-weight: 600;
      padding: 0.4em 1.2em;
      border-radius: 100px;
      border: 1.5px solid var(--accent);
      background: var(--accent-light);
      color: var(--accent);
      cursor: pointer;
      transition: all 0.2s;
    }
    .play-btn:hover { background: var(--accent); color: #fff; }
    .play-btn.playing { background: var(--orange); color: #fff; border-color: var(--orange); }

    /* ── Business impact card ── */
    .impact-result-card {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 0.75rem;
      margin: 1rem 0;
    }

    .impact-metric {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 1rem;
      text-align: center;
    }

    .impact-metric .metric-value {
      font-family: var(--mono);
      font-size: 1.3rem;
      font-weight: 700;
      color: var(--accent);
    }

    .impact-metric .metric-label {
      font-size: 0.7rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.06em;
      margin-top: 0.25rem;
    }

    /* ── Weekly change heatmap ── */
    .weekly-heatmap-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.82rem;
      margin: 1rem 0;
    }

    .weekly-heatmap-table th {
      background: var(--code-bg);
      font-weight: 600;
      font-size: 0.68rem;
      text-transform: uppercase;
      padding: 0.6rem 0.4rem;
      text-align: center;
      border: 1px solid var(--border);
    }

    .weekly-heatmap-table td {
      padding: 0.6rem 0.4rem;
      text-align: center;
      border: 1px solid var(--border);
      font-family: var(--mono);
      font-size: 0.78rem;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }

    .weekly-heatmap-table td:hover {
      outline: 2px solid var(--accent);
      outline-offset: -2px;
      z-index: 1;
    }

    /* ── Reforecast guide ── */
    .reforecast-recommendation {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 1.25rem;
      background: var(--accent-light);
      border: 1px solid var(--accent-mid);
      border-radius: 10px;
      margin: 1rem 0;
    }

    .reforecast-recommendation .rec-icon {
      font-size: 2rem;
      flex-shrink: 0;
    }

    .reforecast-recommendation .rec-text {
      font-size: 0.88rem;
      line-height: 1.5;
    }

    .reforecast-recommendation .rec-text strong {
      color: var(--accent);
    }

    /* ── Text-width cap for readability in wide layout ── */
    .text-cap { max-width: 700px; }
    .text-cap-sm { max-width: 580px; }

    /* ── Two-column section split ── */
    .section-split {
      display: grid;
      grid-template-columns: minmax(260px, 380px) 1fr;
      gap: 3.5rem;
      align-items: start;
    }
    .split-text { }
    .split-text > h2:first-child { margin-top: 0.25rem; }
    .split-text > *:first-child { margin-top: 0; }
    .split-chart { }

    /* Model toggle buttons for MAPEx chart */
    .model-btns {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
      align-items: center;
    }
    .model-btn {
      font-family: var(--sans);
      font-size: 0.72rem;
      font-weight: 600;
      padding: 0.35em 0.9em;
      border-radius: 100px;
      border: 2px solid;
      background: transparent;
      cursor: pointer;
      transition: all 0.18s;
      display: flex;
      align-items: center;
      gap: 0.35em;
    }
    .model-btn .swatch {
      width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0;
    }
    .model-btn.inactive { opacity: 0.35; }
    .model-btn:hover { opacity: 1; }

    /* KaTeX formula cards in split layout */
    .formula-card-inline {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 1.25rem 1.25rem 0.75rem;
      margin: 1rem 0;
      box-shadow: 0 1px 3px rgba(0,0,0,0.04);
      overflow-x: auto;
    }
    .formula-card-inline .formula-note {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-top: 0.6rem;
      line-height: 1.5;
    }
    .formula-card-inline.inside { border-left: 3px solid var(--teal); }
    .formula-card-inline.outside { border-left: 3px solid var(--red); }

    /* Scenario note muted */
    .scenario-note { font-size: 0.8rem; color: var(--text-muted); margin: 0 0 0.6rem; }

    /* Divider in split context */
    .section-divider {
      border: none;
      height: 1px;
      background: var(--border);
      margin: 2.5rem 0;
    }

    /* ── Responsive ── */
    @media (max-width: 900px) {
      .section-split {
        grid-template-columns: 1fr;
        gap: 1.5rem;
      }
    }

    @media (max-width: 640px) {
      html { font-size: 16px; }
      .hero { padding: 3rem 1.25rem 2.5rem; }
      .article { padding: 2rem 1.25rem 3rem; }
      input[type="range"] { width: 140px; }
      .controls { gap: 0.75rem; padding: 0.75rem; }
      .step-cards { grid-template-columns: 1fr; }
      .scenario-btns { gap: 0.35rem; }
      .scenario-btn { font-size: 0.68rem; padding: 0.35em 0.8em; }
      .impact-result-card { grid-template-columns: 1fr 1fr; }
    }
  </style>
</head>
<body>

<!-- ══════════════ HERO ══════════════ -->
<header class="hero">
  <h1>MAPE<span>x</span></h1>
  <p>A visual, interactive guide to <strong>Mean Absolute Percentage Error</strong> and how forecast error changes across prediction horizons.</p>
</header>

<!-- ══════════════ ARTICLE ══════════════ -->
<main class="article">

  <!-- ── Section 1: What is Forecasting? ── -->
  <h2>Why Measuring Forecast Error Matters</h2>
  <p>
    Organizations use forecasts to predict future demand, revenue, inventory needs, and more.
    A forecast is only useful if it's <em>accurate enough</em> to drive good decisions. But how
    do we measure "accurate enough"?
  </p>
  <p>
    One of the most widely used metrics is <span class="highlight">MAPE</span> — the
    <strong>Mean Absolute Percentage Error</strong>. It tells you, on average, how far off your
    predictions are from reality, expressed as a percentage.
  </p>

  <!-- ── Section 2: The MAPE Formula ── -->
  <h2>The MAPE Formula</h2>
  <p>MAPE is calculated in four intuitive steps:</p>

  <div class="step-cards">
    <div class="step-card">
      <div class="step-num">1</div>
      <h5>Error</h5>
      <p>Subtract the forecast from the actual value for each period.</p>
    </div>
    <div class="step-card">
      <div class="step-num">2</div>
      <h5>Absolute</h5>
      <p>Take the absolute value — we care about magnitude, not direction.</p>
    </div>
    <div class="step-card">
      <div class="step-num">3</div>
      <h5>Percentage</h5>
      <p>Divide by the actual value to get a relative error for each period.</p>
    </div>
    <div class="step-card">
      <div class="step-num">4</div>
      <h5>Mean</h5>
      <p>Average all the percentage errors across periods.</p>
    </div>
  </div>

  <div class="formula-card">
    <div class="formula" id="mape-formula"></div>
    <span class="formula-label">
      where <span class="f-actual">A<sub>t</sub></span> = actual value,
      <span class="f-pred">F<sub>t</sub></span> = forecast value,
      <span class="f-var">n</span> = number of periods
    </span>
  </div>

  <div class="callout callout-teal">
    <strong>Interpretation:</strong> A MAPE of 5% means your forecasts are, on average, 5% away from
    the actual values. Lower is better.
  </div>

  <!-- ── Section 3: Interactive MAPE Calculator ── -->
  <h2>See MAPE in Action</h2>
  <p>
    The table below shows a simple example. <strong>Drag the sliders</strong> to change the
    actual values and watch MAPE update in real time. The forecasts are held constant.
  </p>

  <div class="vis-card">
    <h4>Interactive MAPE Calculator</h4>
    <div id="calc-container">
      <table class="calc-table">
        <thead>
          <tr>
            <th>Period</th>
            <th>Actual (Aₜ) — drag to edit</th>
            <th>Forecast (Fₜ)</th>
            <th>|Aₜ − Fₜ| / |Aₜ|</th>
          </tr>
        </thead>
        <tbody id="calc-body"></tbody>
      </table>
      <div id="mape-result" class="mape-result"></div>
    </div>
  </div>

  <div class="callout callout-teal">
    <strong>Larger denominators shrink MAPE:</strong> When actuals increase but absolute errors
    stay constant, percentage error falls (e.g., 10/100 = 10% vs. 10/200 = 5%). This is a
    property of the metric, not a sign of improved forecasting. Be cautious when comparing
    MAPE across products or periods with very different volume levels.
  </div>

  <hr class="divider">

  <!-- ── Section 4: Understanding Horizon and Time Bucket ── -->
  <h2>Understanding Horizon and Time Bucket</h2>

  <div class="step-cards">
    <div class="step-card">
      <div class="step-num">1</div>
      <h5>Horizon (H days)</h5>
      <p>
        The period that includes all transactional activities from day 1 to day H.
        A 14-day horizon means forecasting for a consecutive 14-day window.
      </p>
    </div>
    <div class="step-card">
      <div class="step-num">2</div>
      <h5>Time Bucket</h5>
      <p>
        The aggregation period for estimates and actuals. For daily MAPEx,
        each version has a bucket [V, V+H&minus;1] over which we sum forecasts and actuals.
      </p>
    </div>
    <div class="step-card">
      <div class="step-num">3</div>
      <h5>Lag (Currently 0)</h5>
      <p>
        The delay between forecast generation and forecast period start.
        Lag=0 means forecasts generated on Monday cover Monday+H days.
        We use lag=0 for all MAPEx calculations.
      </p>
    </div>
  </div>

  <div class="callout">
    <strong>Example:</strong> On <span id="example-today"></span> with H=14 and lag=0, the forecast covers
    <span id="example-range-start"></span> &ndash; <span id="example-range-end"></span> (14 days). The time bucket = forecast period = [<span id="example-bucket-start"></span>, <span id="example-bucket-end"></span>].
  </div>

  <!-- ── Section 5: Interactive Time Series + Horizon ── -->
  <hr class="divider">
  <div class="section-split">
    <div class="split-text">
      <h2>Forecasts Across Horizons</h2>
      <p>
        The chart shows actual demand (solid line) and forecasts at different horizons.
        Use the slider to change the horizon — watch how predictions diverge from reality
        as you look further ahead.
      </p>
      <p>
        The shaded region is the absolute error. At short horizons the model closely tracks
        actuals; at 35 days the gap widens visibly.
      </p>
      <div class="controls" style="margin-top:1.5rem;">
        <div class="control-group">
          <label>Forecast Horizon (x)</label>
          <div style="display:flex;align-items:center;gap:0.5rem;">
            <input type="range" id="horizon-slider" min="0" max="4" value="0" step="1">
            <span class="value-display" id="horizon-value">7</span>
            <span style="font-size:0.78rem;color:var(--text-muted);">days ahead</span>
          </div>
        </div>
      </div>
    </div>
    <div class="split-chart">
      <div class="vis-card">
        <h4>Actual vs. Forecast — Adjustable Horizon</h4>
        <div class="legend">
          <div class="legend-item"><div class="legend-swatch" style="background:var(--teal)"></div> Actual</div>
          <div class="legend-item"><div class="legend-swatch" style="background:var(--orange)"></div> Forecast</div>
          <div class="legend-item"><div class="legend-swatch" style="background:rgba(204,0,0,0.15)"></div> Error region</div>
        </div>
        <div id="ts-chart"></div>
        <div id="ts-mape" class="mape-result" style="margin-top:0.75rem;"></div>
      </div>
    </div>
  </div>

  <!-- ── Section 6: MAPE vs Horizon ── -->
  <hr class="divider">
  <h2>MAPEx: Error Grows with Horizon</h2>
  <p class="text-cap">
    Each bar shows MAPEx at that horizon — computed as <strong>Σ|errors| / Σ actuals</strong>
    across all rolling version windows (not divided by H itself, so high-volume days always
    dominate the denominator). Toggle models below to compare how different forecasting
    strategies degrade across horizons.
  </p>

  <div class="vis-card">
    <h4>MAPEx — MAPE at Each Forecast Horizon</h4>

    <div style="display:flex;flex-wrap:wrap;gap:0.75rem;align-items:flex-start;margin-bottom:1rem;">
      <div>
        <p class="scenario-note">Demand scenario:</p>
        <div class="scenario-btns" id="scenario-btns">
          <button class="scenario-btn active" data-scenario="stable">Stable</button>
          <button class="scenario-btn" data-scenario="seasonal">Seasonal</button>
          <button class="scenario-btn" data-scenario="spike">Promo Spike</button>
          <button class="scenario-btn" data-scenario="newproduct">New Product</button>
        </div>
      </div>
      <div>
        <p class="scenario-note">Models to compare:</p>
        <div class="model-btns" id="model-btns">
          <button class="model-btn" data-model="mlModel" style="border-color:#003DA5;color:#003DA5;">
            <span class="swatch" style="background:#003DA5;"></span>ML Model
          </button>
          <button class="model-btn" data-model="naive" style="border-color:#C8D2E4;color:#4A5C7A;">
            <span class="swatch" style="background:#C8D2E4;"></span>Naive
          </button>
          <button class="model-btn" data-model="ma7" style="border-color:#007B5F;color:#007B5F;">
            <span class="swatch" style="background:#007B5F;"></span>MA-7
          </button>
          <button class="model-btn" data-model="ets" style="border-color:#0068B4;color:#0068B4;">
            <span class="swatch" style="background:#0068B4;"></span>Exp. Smoothing
          </button>
          <button class="model-btn" data-model="linTrend" style="border-color:#8B4A00;color:#8B4A00;">
            <span class="swatch" style="background:#8B4A00;"></span>Linear Trend
          </button>
        </div>
      </div>
    </div>

    <div id="mapex-chart"></div>
    <p class="muted" style="margin-top:0.5rem;font-size:0.78rem;">
      ML Model = simulated autoregressive forecast. Naive = last-known value (persistence). MA-7 = 7-day moving average. Exp. Smoothing = α=0.3 ETS. Linear Trend = OLS extrapolation on last 10 known values.
    </p>
  </div>

  <hr class="divider">

  <!-- ── Daily Versions Section ── -->
  <h2>The MAPEx Formula &mdash; Daily Versions</h2>

  <div class="callout" style="background:var(--orange-light);border-left-color:var(--orange);">
    <strong>⚠️ Important Distinction: MAPE ≠ MAPEx</strong>
    <p style="margin:0.5rem 0 0.75rem;">
      Standard <strong>MAPE</strong> averages individual percentage errors — each period contributes equally
      regardless of volume. <strong>MAPEx</strong> is a <em>volume-weighted</em> metric (also known as
      WMAPE): it sums all absolute errors, then divides by the sum of all actuals. This means
      high-volume periods dominate MAPEx while low-volume periods dominate standard MAPE.
    </p>
    <table style="width:100%;border-collapse:collapse;font-size:0.82rem;font-family:var(--mono);">
      <thead>
        <tr>
          <th style="text-align:left;padding:0.4rem 0.6rem;background:rgba(0,0,0,0.05);border:1px solid var(--border);">Metric</th>
          <th style="text-align:left;padding:0.4rem 0.6rem;background:rgba(0,0,0,0.05);border:1px solid var(--border);">Formula Style</th>
          <th style="text-align:left;padding:0.4rem 0.6rem;background:rgba(0,0,0,0.05);border:1px solid var(--border);">Weighting</th>
          <th style="text-align:left;padding:0.4rem 0.6rem;background:rgba(0,0,0,0.05);border:1px solid var(--border);">Zero-Safe?</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="padding:0.35rem 0.6rem;border:1px solid var(--border);font-weight:600;">MAPE</td>
          <td style="padding:0.35rem 0.6rem;border:1px solid var(--border);">Mean of (|error|&nbsp;/&nbsp;actual) per period</td>
          <td style="padding:0.35rem 0.6rem;border:1px solid var(--border);">Equal-weight</td>
          <td style="padding:0.35rem 0.6rem;border:1px solid var(--border);color:var(--red);">No</td>
        </tr>
        <tr>
          <td style="padding:0.35rem 0.6rem;border:1px solid var(--border);font-weight:600;">MAPEx</td>
          <td style="padding:0.35rem 0.6rem;border:1px solid var(--border);">&Sigma;|errors|&nbsp;/&nbsp;&Sigma;&nbsp;actuals over bucket</td>
          <td style="padding:0.35rem 0.6rem;border:1px solid var(--border);">Volume-weight</td>
          <td style="padding:0.35rem 0.6rem;border:1px solid var(--border);color:var(--teal);">Partially</td>
        </tr>
      </tbody>
    </table>
    <p style="margin:0.6rem 0 0;font-size:0.85rem;">
      The rest of this page uses the <strong>MAPEx</strong> (volume-weighted) definition unless stated otherwise.
    </p>
  </div>
  <p>
    The correct MAPEx formula uses a <strong>rolling daily version</strong> approach.
    For each day (version date), we create a forecast for the next H days and compare
    it to actual values once they're available.
  </p>

  <div class="formula-card">
    <div class="formula" id="mapex-formula-daily"></div>
    <span class="formula-label">
      where each version V has a time bucket [V, V+H&minus;1],<br>
      TAE<sub>v</sub> = &Sigma;|F<sub>d</sub> &minus; A<sub>d</sub>| for d &isin; bucket,
      Actuals<sub>v</sub> = &Sigma; A<sub>d</sub> for d &isin; bucket
    </span>
  </div>

  <div class="callout callout-teal">
    <strong>Interpretation:</strong> MAPEx is a volume-weighted error metric. A lower percentage indicates a more accurate forecast. The goal is to minimize this value.
  </div>

  <h3>Daily Versions Explained</h3>
  <p>
    For <strong>today = <span id="dv-today"></span></strong> and <strong>horizon = 14 days</strong>:
  </p>
  <ul style="margin:0.75rem 0 1.25rem 1.5rem;color:var(--text);" id="dv-versions-list">
  </ul>
  <p id="dv-aggregate-text">
  </p>

  <div class="vis-card">
    <h4>Daily Versions Visualized &mdash; Rolling Windows</h4>
    <div class="controls">
      <div class="control-group">
        <label>Horizon (H)</label>
        <select id="daily-horizon-select" style="font-size:0.85rem;padding:0.3em 0.5em;border-radius:6px;border:1px solid var(--border);">
          <option value="7">7 days</option>
          <option value="14" selected>14 days</option>
          <option value="21">21 days</option>
          <option value="28">28 days</option>
          <option value="35">35 days</option>
        </select>
      </div>
      <div class="control-group">
        <label>Show Version</label>
        <div style="display:flex;align-items:center;gap:0.5rem;">
          <input type="range" id="version-slider" min="0" max="15" value="0" step="1">
          <span class="value-display" id="version-date-display">...</span>
          <button class="play-btn" id="version-play-btn">Play</button>
        </div>
      </div>
    </div>
    <div class="legend">
      <div class="legend-item"><div class="legend-swatch" style="background:var(--teal)"></div> Actual</div>
      <div class="legend-item"><div class="legend-swatch" style="background:var(--orange)"></div> Forecast</div>
      <div class="legend-item"><div class="legend-swatch" style="background:rgba(0,61,165,0.08);border:1px dashed var(--accent)"></div> Time Bucket</div>
    </div>
    <div id="daily-versions-chart"></div>
    <div class="mape-result" id="version-stats"></div>
  </div>

  <hr class="divider">

  <!-- ── Forecast Revision Impact Grid ── -->
  <h2>Forecast Revision Impact Across Horizons</h2>
  <p>
    When you edit a forecast in a specific week, it affects different horizon/month
    combinations. The table below shows which months are impacted for each horizon.
  </p>

  <div class="vis-card">
    <h4>Forecast Edit Impact Matrix</h4>
    <table class="impact-table" id="impact-table">
      <thead>
        <tr>
          <th>Editing Week</th>
          <th>H=7 Days</th>
          <th>H=14 Days</th>
          <th>H=21 Days</th>
          <th>H=28 Days</th>
          <th>H=35 Days</th>
        </tr>
      </thead>
      <tbody id="impact-body"></tbody>
    </table>
    <p class="muted" style="margin-top:1rem;text-align:center;">
      Click on a cell to see which months are affected by editing that week's forecast.
    </p>
    <div id="impact-result" class="mape-result" style="display:none;"></div>
  </div>

  <hr class="divider">

  <!-- ── Section 7: Why does error grow? ── -->
  <h2>Why Does Error Grow with Horizon?</h2>

  <div class="step-cards">
    <div class="step-card">
      <div class="step-num" style="background:var(--orange)">1</div>
      <h5>Error Accumulation (Recursive Models)</h5>
      <p>Autoregressive models feed predictions back as inputs, so a small error at step <em>t</em> shifts the input at step <em>t+1</em>, causing errors to compound. Even <strong>direct models</strong> (which predict each horizon independently) show growing error — not from compounding, but because mapping current features to a distant target is inherently harder to learn.</p>
    </div>
    <div class="step-card">
      <div class="step-num" style="background:var(--orange)">2</div>
      <h5>Increasing Uncertainty</h5>
      <p>The further ahead we look, the more unforeseen events can occur. The future is fundamentally uncertain.</p>
    </div>
    <div class="step-card">
      <div class="step-num" style="background:var(--orange)">3</div>
      <h5>Signal Decay</h5>
      <p>Recent observations carry strong signal. As the horizon grows, the model must rely on weaker, older patterns.</p>
    </div>
  </div>

  <hr class="divider">

  <!-- ── Section 8: Interpreting MAPE ── -->
  <h2>Interpreting MAPE Values</h2>

  <div class="vis-card">
    <h4>MAPE Quality Benchmarks</h4>
    <div id="benchmark-chart"></div>
  </div>

  <p class="muted">
    These benchmarks are rough rules of thumb. What counts as "good" depends entirely on the
    domain — a 10% MAPE might be excellent for long-range energy demand forecasts but
    unacceptable for short-term stock predictions.
  </p>

  <hr class="divider">

  <!-- ── Section 9: Limitations ── -->
  <h2>Limitations of MAPE</h2>

  <div class="callout callout-orange">
    <strong>Division by zero:</strong> If any actual value Aₜ is zero, MAPE is undefined.
    This makes MAPE unsuitable for intermittent or sparse data.
  </div>

  <p>
    <strong>Asymmetric penalty:</strong> MAPE penalizes over-forecasts and under-forecasts unevenly
    due to the actual value sitting in the denominator. Consider two scenarios with the same
    absolute miss of 50 units:
  </p>
  <ul style="margin:0.5rem 0 1rem 1.5rem;color:var(--text);line-height:1.8;">
    <li><strong>Over-forecast:</strong> Actual&nbsp;=&nbsp;100, Forecast&nbsp;=&nbsp;150 &rarr; |100&nbsp;&minus;&nbsp;150|&nbsp;/&nbsp;100 = <strong>50%</strong></li>
    <li><strong>Under-forecast:</strong> Actual&nbsp;=&nbsp;150, Forecast&nbsp;=&nbsp;100 &rarr; |150&nbsp;&minus;&nbsp;100|&nbsp;/&nbsp;150 = <strong>33%</strong></li>
  </ul>
  <p>
    Same absolute error, different MAPE — because the denominator changes. More importantly,
    over-forecast errors have no upper bound (a forecast of 1000 when actual is 100 = 900%),
    while under-forecast errors are capped at 100% (forecast of 0 when actual is 100 = 100%).
    This asymmetry can systematically bias model selection toward under-forecasting.
  </p>

  <p>
    <strong>Scale sensitivity at low volumes:</strong> If actual demand is 2 units and you forecast 1,
    the percentage error is 50% — despite only being off by a single unit.
  </p>

  <div class="callout callout-orange">
    <strong>Volume weighting across SKUs:</strong> When computing MAPEx across multiple SKUs
    (products), high-volume items dominate the aggregate MAPE since their absolute errors are
    larger. A single best-selling SKU can skew the overall MAPEx curve, masking poor performance
    on low-volume items. Consider computing MAPE per-SKU first, then averaging, or use WMAPE
    to explicitly weight by volume.
  </div>

  <hr class="divider">

  <!-- ── Section 10: Upload your own data ── -->
  <h2>Try Your Own Data</h2>
  <p>
    Upload a CSV with columns <code>actual</code> and <code>forecast</code> to compute your
    own MAPE. Optionally include a <code>horizon</code> column (e.g. 7, 14, 21, 28, 35) to
    see your own MAPEx curve.
  </p>

  <div class="vis-card">
    <h4>CSV Upload</h4>
    <div class="controls" style="flex-direction:column;align-items:flex-start;">
      <div style="display:flex;align-items:center;gap:1rem;flex-wrap:wrap;">
        <input type="file" id="csv-upload" accept=".csv" style="font-size:0.85rem;">
        <button id="csv-sample-btn" style="font-size:0.78rem;padding:0.4em 1em;border-radius:6px;border:1px solid var(--accent);background:var(--accent-light);color:var(--accent);cursor:pointer;font-weight:600;">Load sample data</button>
      </div>
      <p id="csv-status" class="muted" style="margin:0.5rem 0 0;font-size:0.8rem;"></p>
    </div>
    <div id="csv-result" style="display:none;">
      <div id="csv-mape-result" class="mape-result"></div>
      <div id="csv-mapex-chart" style="margin-top:1rem;"></div>
    </div>
  </div>

  <hr class="divider">

  <!-- ── Section 11: Horizon Lag Visualization ── -->
  <hr class="divider">
  <div class="section-split">
    <div class="split-text">
      <h2>Understanding Horizon Lag</h2>

      <div class="callout callout-teal">
        <strong>Two types of lag:</strong> <strong>Publication lag</strong> (fixed at 0 here) is
        the delay between when a forecast is issued and when its window starts.
        <strong>Information lag</strong> (shown here) is the gap between the last known data
        point and the prediction target — it grows with horizon regardless of publication lag.
      </div>

      <p>
        When you forecast at horizon <span class="highlight-orange">x</span>, the model can only
        use data available <em>today</em> to predict <em>x days from now</em>. Each colored dot
        marks a target the model must predict using only the solid teal region as input.
      </p>
      <p>
        At <span class="highlight">7 days</span> (<span id="lag-date-7"></span>), recent patterns
        are highly relevant. By <span class="highlight-orange">35 days</span>
        (<span id="lag-date-35"></span>), the model must bridge a five-week gap — demand patterns,
        seasonality, and events can all shift. This is why MAPEx rises steeply with horizon.
      </p>
    </div>
    <div class="split-chart">
      <div class="vis-card">
        <h4>Horizon Lag — What the Model "Sees" vs. What It Must Predict</h4>
        <div id="lag-chart"></div>
      </div>
    </div>
  </div>

  <!-- ── Bias Visualization ── -->
  <hr class="divider">
  <div class="section-split">
    <div class="split-text">
      <h2>Forecast Bias by Horizon</h2>
      <p>
        MAPEx measures <em>absolute</em> error — it treats over-forecasting and under-forecasting
        equally in magnitude. But the <strong>direction</strong> of error matters too.
      </p>
      <p>
        A model that consistently over-forecasts by 10% produces 10% MAPEx, and so does one
        that consistently under-forecasts by 10% — yet the business impact is very different
        (overstock vs. stockout). The signed error chart reveals this hidden bias.
      </p>
      <p>
        Positive bars mean the model predicts <span style="color:var(--orange);font-weight:600;">too high</span>;
        negative bars mean it predicts <span style="color:var(--teal);font-weight:600;">too low</span>.
        A flat signed error across horizons suggests consistent bias, not just growing uncertainty.
      </p>
    </div>
    <div class="split-chart">
      <div class="vis-card">
        <h4>Signed Forecast Error by Horizon</h4>
        <div class="legend" style="margin-bottom:0.5rem;">
          <div class="legend-item"><div class="legend-swatch" style="background:var(--orange)"></div> Over-forecast (+)</div>
          <div class="legend-item"><div class="legend-swatch" style="background:var(--teal)"></div> Under-forecast (&minus;)</div>
        </div>
        <div id="bias-chart"></div>
        <div id="bias-summary" class="mape-result" style="margin-top:0.75rem;font-size:1rem;"></div>
      </div>
    </div>
  </div>

  <!-- ── Weekly Forecast Change MAPEx Impact ── -->
  <h2>Weekly Forecast Change &mdash; MAPEx Impact</h2>
  <p>
    When you revise a forecast during a specific week, the change propagates differently
    across horizons. A <strong>5% improvement</strong> in week 1 forecasts might reduce H=7 MAPEx
    significantly but barely move H=35. The heatmap below shows how a forecast revision
    in each week affects MAPEx at every horizon.
  </p>

  <div class="vis-card">
    <h4>MAPEx Change from Weekly Forecast Revision</h4>
    <div class="controls">
      <div class="control-group">
        <label>Revision Size (%)</label>
        <div style="display:flex;align-items:center;gap:0.5rem;">
          <input type="range" id="revision-size-slider" min="1" max="20" value="5" step="1">
          <span class="value-display" id="revision-size-value">5%</span>
        </div>
      </div>
    </div>
    <table class="weekly-heatmap-table" id="weekly-heatmap-table">
      <thead>
        <tr>
          <th>Week Revised</th>
          <th>H=7d</th>
          <th>H=14d</th>
          <th>H=21d</th>
          <th>H=28d</th>
          <th>H=35d</th>
        </tr>
      </thead>
      <tbody id="weekly-heatmap-body"></tbody>
    </table>
    <p class="muted" style="margin-top:0.5rem;text-align:center;font-size:0.78rem;">
      Green = MAPEx improvement. Darker = bigger impact. Hover for details.
    </p>
    <div id="weekly-heatmap-detail" class="mape-result" style="display:none;font-size:0.95rem;"></div>
  </div>

  <hr class="divider">

  <!-- ── Re-forecast Frequency Guide ── -->
  <hr class="divider">
  <div class="section-split" style="align-items:start;">
    <div class="split-text">
      <h2>When to Re-forecast</h2>
      <p>
        The key question is: <strong>does revising a forecast on day&nbsp;<em>d</em> actually
        move your MAPEx score?</strong> The answer depends entirely on whether day&nbsp;<em>d</em>
        falls <em>inside</em> or <em>outside</em> the horizon window being measured.
      </p>

      <h3>The MAPEx formula</h3>
      <p>
        For horizon&nbsp;<em>H</em>, MAPEx is aggregated over all rolling version dates&nbsp;<em>V</em>.
        Each version covers the bucket <span style="font-family:var(--mono);">[V,&nbsp;V+H−1]</span>:
      </p>
      <div class="formula-card-inline">
        <div id="reforecast-formula-main"></div>
        <p class="formula-note">TAE<sub>V</sub> = total absolute error in version V's bucket &nbsp;|&nbsp; denominator is total actuals, <em>not</em> H.</p>
      </div>

      <h3 style="color:var(--teal);">✓ Revising inside the horizon</h3>
      <p>
        If day&nbsp;<em>d</em> is inside at least one version's bucket
        (<span style="font-family:var(--mono);">d ∈ [V, V+H−1]</span>),
        the revision changes TAE<sub>V</sub> by the signed difference in absolute error:
      </p>
      <div class="formula-card-inline inside">
        <div id="reforecast-formula-inside"></div>
        <p class="formula-note">
          The number of versions affected equals min(<em>d</em>, <em>H</em>−1) + 1 — a day near the
          <em>end</em> of the horizon is covered by fewer versions, so the MAPEx impact is smaller.
        </p>
      </div>

      <h3 style="color:var(--red);">✗ Revising outside the horizon</h3>
      <p>
        If day&nbsp;<em>d</em> falls outside every version's bucket for the horizon being measured,
        TAE<sub>V</sub> is unchanged for all V:
      </p>
      <div class="formula-card-inline outside">
        <div id="reforecast-formula-outside"></div>
        <p class="formula-note">
          This is the most common "wasted revision" — a planner edits a forecast that falls
          beyond the H-day window and sees no movement in MAPEx<sub>H</sub>.
        </p>
      </div>

      <div class="callout callout-teal" style="margin-top:1.25rem;">
        <strong>Rule of thumb:</strong> if your MAPEx curve gains more than ~0.15 pp/day between
        two adjacent horizons, re-forecasting at that frequency will produce measurable improvement.
        The chart on the right shows the marginal gain per day for your current scenario.
      </div>
    </div>

    <div class="split-chart">
      <div class="vis-card">
        <h4>Marginal MAPEx Gain — Re-forecasting Frequency</h4>
        <div id="reforecast-chart"></div>
        <div id="reforecast-recommendation" class="reforecast-recommendation" style="margin-top:1rem;"></div>
      </div>
    </div>
  </div>

  <!-- ── Section 12: Takeaways ── -->
  <h2>Key Takeaways</h2>
  <div class="step-cards">
    <div class="step-card" style="border-color:var(--accent-mid)">
      <h5>MAPE is intuitive</h5>
      <p>A percentage-based error that's easy to communicate and compare across datasets.</p>
    </div>
    <div class="step-card" style="border-color:var(--accent-mid)">
      <h5>Horizon matters</h5>
      <p>MAPEx reveals how error grows as you forecast further ahead — essential for setting expectations.</p>
    </div>
    <div class="step-card" style="border-color:var(--accent-mid)">
      <h5>Know the limits</h5>
      <p>MAPE struggles with zeros, is asymmetric, and is sensitive to small actuals. Pair it with other metrics.</p>
    </div>
  </div>

  <!-- ── About the MAPEx Metric ── -->
  <div class="context-section" style="margin-top: 40px; text-align: left; max-width: 600px; margin-left: auto; margin-right: auto;">

    <h3 style="border-bottom: 1px solid #ccc; padding-bottom: 5px;">About the MAPEx Metric</h3>

    <p><strong>MAPEx</strong> is our core metric for measuring demand planning forecast error. Unlike a standard Mean Absolute Percentage Error (MAPE), MAPEx is a <strong>volume-weighted</strong> measure.</p>

    <ul>
        <li><strong>Volume-Weighted:</strong> It aggregates all absolute errors first, then divides by the sum of all actuals. This means that high-volume products have a greater impact on the final score, which correctly reflects their business importance.</li>

        <li><strong>Handles Zeroes (Mostly):</strong> Because MAPEx divides total absolute error by the <em>sum</em> of all actuals across the bucket (rather than averaging individual ratios), a single zero-actual period doesn't cause a division-by-zero — it simply contributes zero to the denominator sum. However, if <em>all</em> actual values within the entire bucket are zero (e.g., a new product with no sales history in the forecast window), MAPEx is still undefined. For truly intermittent demand, consider complementary metrics like RMSSE or coverage-based measures.</li>

        <li><strong>Forecast Horizon (X):</strong> In practice, MAPEx is always measured over a specific lead time or "horizon" (e.g., 7, 14, 21 days), denoted as MAPEx7, MAPEx14, etc. This calculator demonstrates the core formula used for any given horizon.</li>
    </ul>

  </div>

</main>

<!-- ══════════════ FOOTER ══════════════ -->
<footer class="footer">
  <p>
    <strong>MAPEx</strong> — An interactive explainer on forecast error.
    Built with <a href="https://d3js.org/" target="_blank" rel="noopener">D3.js</a>.
  </p>
</footer>

<!-- ══════════════ TOOLTIP ══════════════ -->
<div class="tooltip" id="tooltip"></div>

<!-- ══════════════ DEMAND GENERATOR PANEL ══════════════ -->
<div id="demand-gen-panel" style="
  position: fixed;
  bottom: 24px;
  right: 24px;
  z-index: 9999;
  background: #0A1F44;
  border: 1px solid rgba(77,121,192,0.5);
  border-radius: 12px;
  padding: 14px 18px;
  display: flex;
  align-items: center;
  gap: 12px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.3);
  font-family: inherit;
  color: #E6EBF7;
">
  <span style="font-size: 13px; font-weight: 700; opacity: 0.9; white-space:nowrap;">&#x1F3B2; Demand</span>
  <select id="scenario-select" style="
    background: #0D2B5E;
    color: #E6EBF7;
    border: 1px solid rgba(77,121,192,0.4);
    border-radius: 6px;
    padding: 6px 10px;
    font-size: 13px;
    cursor: pointer;
    font-family: inherit;
  ">
    <option value="stable">Stable</option>
    <option value="seasonal">Seasonal</option>
    <option value="promo">Promo Spike</option>
    <option value="newProduct">New Product</option>
  </select>
  <button id="randomize-btn" style="
    background: linear-gradient(135deg, #003DA5, #0068B4);
    color: white;
    border: none;
    border-radius: 6px;
    padding: 8px 16px;
    font-size: 13px;
    font-weight: 700;
    cursor: pointer;
    transition: transform 0.1s, opacity 0.15s;
    font-family: inherit;
    white-space: nowrap;
  " onmousedown="this.style.transform='scale(0.95)'"
     onmouseup="this.style.transform='scale(1)'"
  >
    Randomize &#x21BB;
  </button>
  <span id="seed-display" style="font-size: 11px; opacity: 0.4; min-width:4ch;"></span>
</div>

<!-- ══════════════ DEMAND GENERATOR ══════════════ -->
<script>
/**
 * MAPEx Random Demand Generator
 * Global module — call DemandGenerator.generate(scenario) to get a full dataset.
 */
const DemandGenerator = (() => {
  function randBetween(min, max) { return Math.random() * (max - min) + min; }
  function randInt(min, max) { return Math.floor(randBetween(min, max + 1)); }
  function gaussianNoise(mean, stddev) {
    mean = mean || 0; stddev = stddev || 1;
    const u1 = Math.random(), u2 = Math.random();
    return mean + stddev * Math.sqrt(-2 * Math.log(u1 || 1e-10)) * Math.cos(2 * Math.PI * u2);
  }

  const HORIZONS = [7, 14, 21, 28, 35];
  const NUM_DAYS = 90;

  function stableDemand() {
    const baseLevel = randInt(80, 200);
    const noise = randBetween(5, 15);
    const actuals = [];
    for (let d = 0; d < NUM_DAYS; d++) {
      actuals.push(Math.max(1, Math.round(baseLevel + gaussianNoise(0, baseLevel * noise / 100))));
    }
    return { actuals, ...generateForecasts(actuals) };
  }

  function seasonalDemand() {
    const baseLevel = randInt(100, 250);
    const amplitude = randBetween(0.2, 0.5);
    const period = randInt(25, 35);
    const phaseShift = randBetween(0, 2 * Math.PI);
    const noise = randBetween(5, 12);
    const actuals = [];
    for (let d = 0; d < NUM_DAYS; d++) {
      const seasonal = baseLevel * amplitude * Math.sin((2 * Math.PI * d / period) + phaseShift);
      actuals.push(Math.max(1, Math.round(baseLevel + seasonal + gaussianNoise(0, baseLevel * noise / 100))));
    }
    return { actuals, ...generateForecasts(actuals) };
  }

  function promoSpikeDemand() {
    const baseLevel = randInt(80, 180);
    const noise = randBetween(5, 10);
    const numPromos = randInt(1, 3);
    const promos = [];
    for (let p = 0; p < numPromos; p++) {
      promos.push({ start: randInt(10, NUM_DAYS - 20), duration: randInt(3, 7), multiplier: randBetween(1.8, 3.5) });
    }
    const actuals = [];
    for (let d = 0; d < NUM_DAYS; d++) {
      let mult = 1;
      for (const promo of promos) {
        if (d >= promo.start && d < promo.start + promo.duration) mult = Math.max(mult, promo.multiplier);
      }
      actuals.push(Math.max(1, Math.round(baseLevel * mult + gaussianNoise(0, baseLevel * noise / 100))));
    }
    return { actuals, promos, ...generateForecasts(actuals, promos) };
  }

  function newProductLaunch() {
    const peakLevel = randInt(150, 400);
    const rampDays = randInt(15, 30);
    const noise = randBetween(8, 18);
    const actuals = [];
    for (let d = 0; d < NUM_DAYS; d++) {
      const rampFraction = 1 / (1 + Math.exp(-0.3 * (d - rampDays)));
      actuals.push(Math.max(0, Math.round(peakLevel * rampFraction + gaussianNoise(0, peakLevel * noise / 100 * rampFraction))));
    }
    return { actuals, ...generateForecasts(actuals) };
  }

  function generateForecasts(actuals, promos) {
    promos = promos || [];
    const forecasts = {};
    for (const h of HORIZONS) {
      forecasts[h] = [];
      const biasDrift = gaussianNoise(0, 0.02 * Math.sqrt(h / 7));
      const noiseScale = 0.03 + 0.025 * (h / 7);
      for (let d = 0; d < NUM_DAYS; d++) {
        const lookbackEnd = Math.max(0, d - h);
        let recentAvg = 0, count = 0;
        for (let lb = Math.max(0, lookbackEnd - 14); lb <= lookbackEnd; lb++) { recentAvg += actuals[lb]; count++; }
        recentAvg = count > 0 ? recentAvg / count : actuals[0];
        const errorMagnitude = recentAvg * noiseScale;
        let forecastVal = recentAvg * (1 + biasDrift) + gaussianNoise(0, errorMagnitude);
        for (const promo of promos) {
          if (d >= promo.start && d < promo.start + promo.duration) {
            if (Math.random() >= Math.max(0, 1 - h / 42)) {
              forecastVal -= actuals[d] * (promo.multiplier - 1) * randBetween(0.4, 0.8);
            }
          }
        }
        forecasts[h].push(Math.max(1, Math.round(forecastVal)));
      }
    }
    const mapex = {};
    for (const h of HORIZONS) {
      let totalAbsError = 0, totalActuals = 0;
      for (let v = 0; v <= NUM_DAYS - h; v++) {
        for (let d = v; d < v + h; d++) {
          totalAbsError += Math.abs(forecasts[h][d] - actuals[d]);
          totalActuals += actuals[d];
        }
      }
      mapex[h] = totalActuals > 0 ? (totalAbsError / totalActuals) * 100 : null;
    }
    return { forecasts, horizons: HORIZONS, mapex, numDays: NUM_DAYS };
  }

  const scenarios = { stable: stableDemand, seasonal: seasonalDemand, promo: promoSpikeDemand, newProduct: newProductLaunch };
  function generate(scenarioKey) { const gen = scenarios[scenarioKey || 'stable'] || scenarios.stable; return gen(); }
  function getScenarioNames() { return Object.keys(scenarios); }
  return { generate, getScenarioNames, HORIZONS, NUM_DAYS };
})();
</script>

<!-- ══════════════ SCRIPTS ══════════════ -->
<script>
(function () {
  "use strict";

  const accent = "#003DA5";
  const orange = "#CC0000";
  const teal = "#007B5F";
  const red = "#CC0000";
  const green = "#007B5F";
  const blue = "#0068B4";
  const textMuted = "#4A5C7A";
  const border = "#D0D8E8";
  const ghost = "#C8D2E4";

  // Day-based horizons
  const HORIZONS = [7, 14, 21, 28, 35];

  // Dynamic "today" — always the current system date
  const TODAY = new Date();
  TODAY.setHours(0, 0, 0, 0);
  const fmt = d3.timeFormat("%b %d");
  const fmtFull = d3.timeFormat("%b %d, %Y");
  const fmtMonth = d3.timeFormat("%B");
  const fmtMonthShort = d3.timeFormat("%b");

  // Helper: add days to a date
  function addDays(date, n) {
    return new Date(date.getTime() + n * 86400000);
  }

  // Day-of-week names
  const dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];

  // Populate dynamic date spans across the site
  (function populateDynamicDates() {
    const dayName = dayNames[TODAY.getDay()];

    // Example callout: "On Monday Feb 16 with H=14..."
    var h14End = addDays(TODAY, 14);
    var el;
    el = document.getElementById("example-today");
    if (el) el.textContent = dayName + " " + fmt(TODAY);
    el = document.getElementById("example-range-start");
    if (el) el.textContent = fmt(TODAY);
    el = document.getElementById("example-range-end");
    if (el) el.textContent = fmt(h14End);
    el = document.getElementById("example-bucket-start");
    if (el) el.textContent = fmt(TODAY);
    el = document.getElementById("example-bucket-end");
    if (el) el.textContent = fmt(h14End);

    // Daily Versions Explained
    el = document.getElementById("dv-today");
    if (el) el.textContent = fmtFull(TODAY);

    var latestVersion = addDays(TODAY, -14 + 1); // Version whose bucket ends today
    var prevVersion = addDays(latestVersion, -1);
    var earliestVersion = addDays(TODAY, -14 - 14 + 1); // ~14 versions back
    var listEl = document.getElementById("dv-versions-list");
    if (listEl) {
      listEl.innerHTML =
        "<li><strong>Version " + fmt(latestVersion) + ":</strong> Bucket = " + fmt(latestVersion) + "&ndash;" + fmt(addDays(latestVersion, 13)) + " (14 days), all actuals available &#10003;</li>" +
        "<li><strong>Version " + fmt(prevVersion) + ":</strong> Bucket = " + fmt(prevVersion) + "&ndash;" + fmt(addDays(prevVersion, 13)) + " (14 days), all actuals available &#10003;</li>" +
        "<li>...going back to <strong>Version " + fmt(earliestVersion) + ":</strong> Bucket = " + fmt(earliestVersion) + " &ndash; " + fmt(addDays(earliestVersion, 13)) + "</li>";
    }

    var aggEl = document.getElementById("dv-aggregate-text");
    if (aggEl) {
      aggEl.innerHTML = "For " + fmtMonth(TODAY) + " MAPEx (H=14), we aggregate versions from <strong>" + fmt(earliestVersion) + " to " + fmt(latestVersion) + "</strong> (all versions where the bucket falls within or overlaps " + fmtMonth(TODAY) + " and actuals are available).";
    }

    // Horizon Lag description dates
    el = document.getElementById("lag-date-7");
    if (el) el.textContent = fmt(addDays(TODAY, 7));
    el = document.getElementById("lag-date-35");
    if (el) el.textContent = fmt(addDays(TODAY, 35));
  })();

  const tooltip = d3.select("#tooltip");

  function showTooltip(evt, html) {
    tooltip.html(html).style("opacity", 1);
    const ttNode = tooltip.node();
    const ttRect = ttNode.getBoundingClientRect();
    let left = evt.pageX + 12;
    let top = evt.pageY - 28;
    if (left + ttRect.width > window.innerWidth - 16) left = evt.pageX - ttRect.width - 12;
    tooltip.style("left", left + "px").style("top", top + "px");
  }

  function hideTooltip() { tooltip.style("opacity", 0); }

  /* ═══════════════════════════════════════
     1) Interactive MAPE Calculator Table
        Actuals are editable, Forecasts are constant
     ═══════════════════════════════════════ */
  let calcActuals = [100, 120, 90, 110, 105];
  let calcForecasts = [95, 130, 85, 100, 115]; // updated by generator

  function updateMapeDisplay() {
    let sumPctErr = 0;
    calcActuals.forEach((a, i) => {
      const f = calcForecasts[i];
      sumPctErr += a !== 0 ? Math.abs(a - f) / Math.abs(a) : 0;
    });
    d3.select("#mape-result").text("MAPE = " + ((sumPctErr / calcActuals.length) * 100).toFixed(2) + "%");
  }

  function renderCalcTable() {
    const tbody = d3.select("#calc-body");
    tbody.selectAll("tr").remove();

    calcActuals.forEach((a, i) => {
      const f = calcForecasts[i];
      const pctErr = a !== 0 ? Math.abs(a - f) / Math.abs(a) : 0;

      const tr = tbody.append("tr");
      tr.append("td").text("t" + (i + 1));

      // Actual column: editable slider
      const tdA = tr.append("td");
      const inp = tdA.append("input")
        .attr("type", "range")
        .attr("min", Math.round(f * 0.5))
        .attr("max", Math.round(f * 2))
        .attr("step", "0.5")
        .attr("value", a)
        .style("width", "90px");
      const actualSpan = tdA.append("span")
        .attr("class", "col-actual")
        .style("margin-left", "0.4rem")
        .style("font-family", "var(--mono)")
        .text(Math.round(a));

      // Forecast column: constant display
      tr.append("td").attr("class", "col-pred").text(f);

      const errorCell = tr.append("td").attr("class", "col-error").text((pctErr * 100).toFixed(1) + "%");

      inp.on("input", function () {
        calcActuals[i] = +this.value;
        const newA = calcActuals[i];
        const newPctErr = newA !== 0 ? Math.abs(newA - f) / Math.abs(newA) : 0;
        actualSpan.text(Math.round(newA));
        errorCell.text((newPctErr * 100).toFixed(1) + "%");
        updateMapeDisplay();
      });
    });

    updateMapeDisplay();
  }
  renderCalcTable();

  /* ═══════════════════════════════════════
     2) Time Series Forecast Chart
     ═══════════════════════════════════════ */
  function seededRandom(seed) {
    let s = seed;
    return function () {
      s = (s * 16807 + 0) % 2147483647;
      return (s - 1) / 2147483646;
    };
  }

  const rng = seededRandom(42);
  const N = 30;
  const actuals = [];
  let val = 100;
  for (let i = 0; i < N; i++) {
    val += (rng() - 0.45) * 8 + 0.3;
    val = Math.max(val, 20);
    actuals.push(Math.round(val * 10) / 10);
  }

  // Generate forecasts with error proportional to horizon (in days)
  function generateForecasts(horizonDays) {
    const rng2 = seededRandom(123 + horizonDays);
    const factor = horizonDays / 7; // normalise so day 7 ≈ old horizon 1
    return actuals.map((a, i) => {
      const noise = (rng2() - 0.5) * 2 * factor * 2.2;
      const drift = factor * 0.4 * (rng2() - 0.45);
      return Math.round((a + noise + drift) * 10) / 10;
    });
  }

  function computeMAPE(act, pred) {
    let totalAbsoluteError = 0;
    let totalActual = 0;
    act.forEach((a, i) => {
      if (pred[i] !== undefined) {
        totalAbsoluteError += Math.abs(a - pred[i]);
        totalActual += a;
      }
    });
    if (totalActual === 0) {
      return totalAbsoluteError > 0 ? Infinity : 0;
    }
    const mapexError = totalAbsoluteError / totalActual;
    return mapexError * 100;
  }

  const tsMargin = { top: 20, right: 20, bottom: 35, left: 50 };
  const tsContainer = d3.select("#ts-chart");

  // Dynamic dates starting from TODAY
  const tsToday = TODAY;
  const tsDates = d3.range(N).map(i => addDays(tsToday, i));
  const tsDateFmt = d3.timeFormat("%b %d");

  function renderTSChart() {
    tsContainer.selectAll("*").remove();
    const cw = tsContainer.node().getBoundingClientRect().width;
    const width = cw;
    const height = Math.min(340, cw * 0.5);
    const iw = width - tsMargin.left - tsMargin.right;
    const ih = height - tsMargin.top - tsMargin.bottom;

    const sliderIdx = +d3.select("#horizon-slider").property("value");
    const horizonDays = HORIZONS[sliderIdx];
    d3.select("#horizon-value").text(horizonDays);
    const forecasts = generateForecasts(horizonDays);
    const mape = computeMAPE(actuals, forecasts);
    const targetDate = new Date(tsToday.getTime() + horizonDays * 86400000);
    d3.select("#ts-mape").text(
      "MAPEx at horizon " + horizonDays + " days (target: " + tsDateFmt(targetDate) + ") = " + (mape === Infinity ? "Error: Forecast with zero actuals" : mape.toFixed(2) + "%")
    );

    const svg = tsContainer.append("svg")
      .attr("viewBox", `0 0 ${width} ${height}`)
      .attr("preserveAspectRatio", "xMidYMid meet");

    const g = svg.append("g").attr("transform", `translate(${tsMargin.left},${tsMargin.top})`);

    const x = d3.scaleTime().domain([tsDates[0], tsDates[N - 1]]).range([0, iw]);
    const allVals = actuals.concat(forecasts);
    const y = d3.scaleLinear().domain([d3.min(allVals) - 5, d3.max(allVals) + 5]).range([ih, 0]);

    // X axis: show exactly the 5 horizon dates
    const horizonTickDates = HORIZONS.map(h => addDays(tsToday, h));
    g.append("g").attr("transform", `translate(0,${ih})`)
      .call(d3.axisBottom(x).tickValues(horizonTickDates).tickFormat(d3.timeFormat("%b %d")))
      .call(g => g.select(".domain").attr("stroke", border))
      .call(g => g.selectAll(".tick line").attr("stroke", border))
      .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.6rem"));

    g.append("g")
      .call(d3.axisLeft(y).ticks(6))
      .call(g => g.select(".domain").attr("stroke", border))
      .call(g => g.selectAll(".tick line").attr("stroke", border))
      .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.65rem"));

    g.append("g").attr("class", "grid")
      .call(d3.axisLeft(y).ticks(6).tickSize(-iw).tickFormat(""))
      .call(g => g.select(".domain").remove())
      .call(g => g.selectAll(".tick line").attr("stroke", border).attr("stroke-opacity", 0.5));

    // Error area
    const area = d3.area()
      .x((d, i) => x(tsDates[i]))
      .y0((d, i) => y(Math.min(actuals[i], forecasts[i])))
      .y1((d, i) => y(Math.max(actuals[i], forecasts[i])))
      .curve(d3.curveMonotoneX);

    g.append("path").datum(actuals).attr("d", area)
      .attr("fill", "rgba(204,0,0,0.12)").attr("stroke", "none");

    const lineGen = d3.line().x((d, i) => x(tsDates[i])).y(d => y(d)).curve(d3.curveMonotoneX);

    g.append("path").datum(actuals).attr("d", lineGen)
      .attr("fill", "none").attr("stroke", teal).attr("stroke-width", 2.5);

    g.append("path").datum(forecasts).attr("d", lineGen)
      .attr("fill", "none").attr("stroke", orange).attr("stroke-width", 2).attr("stroke-dasharray", "6 3");

    g.selectAll(".dot-actual").data(actuals).enter()
      .append("circle")
      .attr("cx", (d, i) => x(tsDates[i])).attr("cy", d => y(d)).attr("r", 3).attr("fill", teal)
      .on("mouseover", function (evt, d) {
        const i = actuals.indexOf(d);
        showTooltip(evt, `${tsDateFmt(tsDates[i])}<br>Actual: ${d}<br>Forecast: ${forecasts[i]}<br>Error: ${(Math.abs(d - forecasts[i]) / Math.abs(d) * 100).toFixed(1)}%`);
      })
      .on("mousemove", function (evt) { showTooltip(evt, tooltip.html()); })
      .on("mouseout", hideTooltip);
  }

  renderTSChart();
  d3.select("#horizon-slider").on("input", renderTSChart);

  /* ═══════════════════════════════════════
     3) MAPEx Chart — MAPE vs Horizon (days)
        with ghost bars, confidence bands, naive
        baseline, and scenario support
     ═══════════════════════════════════════ */
  const mapexMargin = { top: 24, right: 30, bottom: 40, left: 58 };
  let previousMapexData = null;
  let currentScenario = "stable";

  // Which models are currently visible (toggled on)
  var activeModels = { mlModel: true, naive: false, ma7: false, ets: false, linTrend: false };

  // Model display config
  var modelConfig = {
    mlModel:  { label: "ML Model",        color: accent,    dash: "none",  width: 2.5 },
    naive:    { label: "Naive",           color: ghost,     dash: "5 3",   width: 1.8 },
    ma7:      { label: "MA-7",            color: teal,      dash: "8 3",   width: 2 },
    ets:      { label: "Exp. Smoothing",  color: blue,      dash: "3 3",   width: 2 },
    linTrend: { label: "Linear Trend",    color: "#8B4A00", dash: "6 2 2 2", width: 2 }
  };

  // Scenario demand pattern generators
  const scenarios = {
    stable:     function(rng, i, base) { return base + (rng() - 0.5) * 3; },
    seasonal:   function(rng, i, base) { return base + Math.sin(i * 2 * Math.PI / 30) * 20 + (rng() - 0.5) * 4; },
    spike:      function(rng, i, base) { return base + (i >= 25 && i <= 35 ? 40 : 0) + (rng() - 0.5) * 4; },
    newproduct: function(rng, i, base) { return base * (0.3 + 0.7 * Math.min(i / 40, 1)) + (rng() - 0.5) * 5; }
  };

  function computeModelMAPEx(predictions, act2, H) {
    var totalTAE = 0, totalActuals = 0;
    var maxV = act2.length - H;
    for (var vi = 0; vi < maxV; vi++) {
      for (var di = vi; di < vi + H; di++) {
        totalTAE += Math.abs(predictions[di] - act2[di]);
        totalActuals += act2[di];
      }
    }
    return totalActuals > 0 ? (totalTAE / totalActuals) * 100 : null;
  }

  function computeMapexData(noise, trend, scenario) {
    var sc = scenarios[scenario] || scenarios.stable;
    var N2 = 60;
    var nSim = 20;

    return HORIZONS.map(function(H) {
      var lists = { mlModel: [], naive: [], ma7: [], ets: [], linTrend: [] };

      for (var sim = 0; sim < nSim; sim++) {
        var rng3 = seededRandom(77 + sim * 13);
        var act2 = [];
        var v = 100;
        for (var i = 0; i < N2; i++) {
          v = sc(rng3, i, v);
          v += (rng3() - 0.5) * noise * 1.5 + trend * 0.3;
          v = Math.max(v, 20);
          act2.push(Math.round(v * 10) / 10);
        }

        // ML Model: simulated autoregressive with horizon-dependent noise
        var rng4 = seededRandom(200 + H + sim * 7);
        var mlPred = act2.map(function(a) {
          var factor = H / 7;
          var n = (rng4() - 0.5) * 2 * factor * noise * 0.6;
          var d2 = factor * trend * 0.15 * (rng4() - 0.4);
          return a + n + d2;
        });

        // Naive: last known value at H steps back
        var naivePred = act2.map(function(a, idx) {
          return idx >= H ? act2[idx - H] : act2[0];
        });

        // MA-7: average of 7 known values ending H steps back
        var ma7Pred = act2.map(function(a, idx) {
          var lb = idx - H;
          if (lb < 0) return act2[0];
          var sum = 0, cnt = 0;
          for (var k = Math.max(0, lb - 6); k <= lb; k++) { sum += act2[k]; cnt++; }
          return sum / cnt;
        });

        // Exp. Smoothing (α=0.3) up to known data H steps back
        var alpha = 0.3;
        var etsPred = new Array(N2).fill(act2[0]);
        for (var k = 1; k < N2; k++) {
          var lb2 = k - H;
          if (lb2 <= 0) { etsPred[k] = act2[0]; continue; }
          etsPred[k] = alpha * act2[lb2] + (1 - alpha) * etsPred[k - 1];
        }

        // Linear Trend: OLS on last 10 known values, extrapolate H steps forward
        var linPred = act2.map(function(a, idx) {
          var lb3 = idx - H;
          if (lb3 < 2) return act2[0];
          var nPts = Math.min(10, lb3 + 1);
          var start = lb3 - nPts + 1;
          var sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
          for (var k = start; k <= lb3; k++) {
            var x2 = k - start;
            sumX += x2; sumY += act2[k]; sumXY += x2 * act2[k]; sumX2 += x2 * x2;
          }
          var denom = nPts * sumX2 - sumX * sumX;
          var slope = denom !== 0 ? (nPts * sumXY - sumX * sumY) / denom : 0;
          var intercept = (sumY - slope * sumX) / nPts;
          return Math.max(5, intercept + slope * (lb3 - start + H));
        });

        lists.mlModel.push(computeModelMAPEx(mlPred, act2, H));
        lists.naive.push(computeModelMAPEx(naivePred, act2, H));
        lists.ma7.push(computeModelMAPEx(ma7Pred, act2, H));
        lists.ets.push(computeModelMAPEx(etsPred, act2, H));
        lists.linTrend.push(computeModelMAPEx(linPred, act2, H));
      }

      var result = { horizon: H };
      Object.keys(lists).forEach(function(key) {
        var lst = lists[key].filter(function(x) { return x !== null; });
        lst.sort(function(a, b) { return a - b; });
        result[key] = lst[Math.floor(lst.length * 0.5)] || 0;
      });
      return result;
    });
  }

  var FIXED_NOISE = 4;
  var FIXED_TREND = 3;

  function renderMAPExChart() {
    var container = d3.select("#mapex-chart");
    container.selectAll("*").remove();

    var noise = FIXED_NOISE;
    var trend = FIXED_TREND;

    var mapexData = computeMapexData(noise, trend, currentScenario);

    var cw = container.node().getBoundingClientRect().width;
    var width = cw;
    var height = Math.min(380, cw * 0.48);
    var iw = width - mapexMargin.left - mapexMargin.right;
    var ih = height - mapexMargin.top - mapexMargin.bottom;

    // yMax across all active models
    var allVals = [];
    mapexData.forEach(function(d) {
      Object.keys(activeModels).forEach(function(m) {
        if (activeModels[m] && d[m] != null) allVals.push(d[m]);
      });
    });
    if (allVals.length === 0) allVals = [10];
    var yMax = d3.max(allVals) * 1.2;

    var svg = container.append("svg")
      .attr("viewBox", "0 0 " + width + " " + height)
      .attr("preserveAspectRatio", "xMidYMid meet");

    var g = svg.append("g").attr("transform", "translate(" + mapexMargin.left + "," + mapexMargin.top + ")");

    var x = d3.scaleBand().domain(HORIZONS).range([0, iw]).padding(0.28);
    var y = d3.scaleLinear().domain([0, yMax]).range([ih, 0]);
    var xMid = function(H) { return x(H) + x.bandwidth() / 2; };

    // Axes
    g.append("g").attr("transform", "translate(0," + ih + ")")
      .call(d3.axisBottom(x).tickFormat(function(d) { return d + "d"; }))
      .call(function(g) { g.select(".domain").attr("stroke", border); })
      .call(function(g) { g.selectAll(".tick line").attr("stroke", border); })
      .call(function(g) { g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.65rem"); });

    g.append("text").attr("x", iw / 2).attr("y", ih + 34)
      .attr("text-anchor", "middle").attr("fill", textMuted)
      .style("font-size", "0.72rem").text("Forecast Horizon (days)");

    g.append("g")
      .call(d3.axisLeft(y).ticks(6).tickFormat(function(d) { return d.toFixed(0) + "%"; }))
      .call(function(g) { g.select(".domain").attr("stroke", border); })
      .call(function(g) { g.selectAll(".tick line").attr("stroke", border); })
      .call(function(g) { g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.65rem"); });

    g.append("text").attr("transform", "rotate(-90)")
      .attr("x", -ih / 2).attr("y", -44)
      .attr("text-anchor", "middle").attr("fill", textMuted)
      .style("font-size", "0.72rem").text("MAPEx (%)");

    // Grid lines
    g.append("g")
      .call(d3.axisLeft(y).ticks(6).tickSize(-iw).tickFormat(""))
      .call(function(g) { g.select(".domain").remove(); })
      .call(function(g) { g.selectAll(".tick line").attr("stroke", border).attr("stroke-opacity", 0.45); });

    // ML Model bars (primary model only, when active)
    if (activeModels.mlModel) {
      var colorScale = d3.scaleSequential()
        .domain([0, yMax])
        .interpolator(d3.interpolateRgb(accent, orange));

      g.selectAll(".horizon-bar")
        .data(mapexData)
        .enter()
        .append("rect")
        .attr("class", "horizon-bar")
        .attr("x", function(d) { return x(d.horizon); })
        .attr("width", x.bandwidth())
        .attr("y", ih).attr("height", 0).attr("rx", 4)
        .attr("fill", function(d) { return colorScale(d.mlModel); })
        .on("mouseover", function(evt, d) {
          d3.select(this).attr("opacity", 0.8);
          var tt = "H=" + d.horizon + "d";
          Object.keys(activeModels).forEach(function(m) {
            if (activeModels[m]) tt += "<br><span style='color:" + modelConfig[m].color + "'>" + modelConfig[m].label + ": " + d[m].toFixed(2) + "%</span>";
          });
          showTooltip(evt, tt);
        })
        .on("mousemove", function(evt) { showTooltip(evt, tooltip.html()); })
        .on("mouseout", function() { d3.select(this).attr("opacity", 1); hideTooltip(); })
        .transition().duration(600).delay(function(d, i) { return i * 50; })
        .attr("y", function(d) { return y(d.mlModel); })
        .attr("height", function(d) { return ih - y(d.mlModel); });

      g.selectAll(".bar-label")
        .data(mapexData)
        .enter()
        .append("text")
        .attr("x", function(d) { return xMid(d.horizon); })
        .attr("y", function(d) { return y(d.mlModel) - 5; })
        .attr("text-anchor", "middle").attr("fill", textMuted)
        .style("font-size", "0.58rem").style("font-family", "var(--mono)")
        .style("opacity", 0).text(function(d) { return d.mlModel.toFixed(1) + "%"; })
        .transition().duration(600).delay(function(d, i) { return i * 50 + 300; })
        .style("opacity", 1);
    }

    // Overlay lines for each active model
    var lineGen = d3.line()
      .x(function(d) { return d[0]; })
      .y(function(d) { return d[1]; })
      .curve(d3.curveMonotoneX);

    Object.keys(activeModels).forEach(function(m) {
      if (!activeModels[m]) return;
      var cfg = modelConfig[m];
      var pts = mapexData.map(function(d) { return [xMid(d.horizon), y(d[m])]; });

      // Line
      g.append("path").datum(pts)
        .attr("d", lineGen)
        .attr("fill", "none")
        .attr("stroke", cfg.color)
        .attr("stroke-width", cfg.width)
        .attr("stroke-dasharray", cfg.dash === "none" ? null : cfg.dash)
        .attr("opacity", m === "mlModel" ? 0.65 : 0.85);

      // Dots
      g.selectAll(".dot-" + m).data(mapexData).enter()
        .append("circle")
        .attr("class", "dot-" + m)
        .attr("cx", function(d) { return xMid(d.horizon); })
        .attr("cy", function(d) { return y(d[m]); })
        .attr("r", 4.5)
        .attr("fill", cfg.color)
        .attr("stroke", "#fff")
        .attr("stroke-width", 1.5)
        .on("mouseover", function(evt, d) {
          var tt = "<strong>H=" + d.horizon + "d — " + cfg.label + "</strong><br>MAPEx: " + d[m].toFixed(2) + "%";
          showTooltip(evt, tt);
        })
        .on("mousemove", function(evt) { showTooltip(evt, tooltip.html()); })
        .on("mouseout", hideTooltip);
    });

    // Store for downstream features
    previousMapexData = mapexData;
    renderBiasChart(noise, trend, currentScenario);
    renderReforecastGuide(mapexData);
  }

  // Scenario button wiring
  d3.selectAll("#scenario-btns .scenario-btn").on("click", function() {
    d3.selectAll("#scenario-btns .scenario-btn").classed("active", false);
    d3.select(this).classed("active", true);
    currentScenario = d3.select(this).attr("data-scenario");
    renderMAPExChart();
  });

  // Model toggle button wiring
  d3.selectAll("#model-btns .model-btn").each(function() {
    var m = d3.select(this).attr("data-model");
    if (activeModels[m]) d3.select(this).classed("inactive", false);
    else d3.select(this).classed("inactive", true);
  });
  d3.selectAll("#model-btns .model-btn").on("click", function() {
    var m = d3.select(this).attr("data-model");
    activeModels[m] = !activeModels[m];
    d3.select(this).classed("inactive", !activeModels[m]);
    renderMAPExChart();
  });

  renderMAPExChart();

  /* ═══════════════════════════════════════
     3b) Daily Versions Demo
     ═══════════════════════════════════════ */
  const dailyMargin = { top: 20, right: 30, bottom: 50, left: 60 };

  function renderDailyVersionsChart() {
    const container = d3.select("#daily-versions-chart");
    container.selectAll("*").remove();

    const H = +d3.select("#daily-horizon-select").property("value");
    const versionIdx = +d3.select("#version-slider").property("value");

    // Generate synthetic data: 50 days ending around today
    const nDays = 50;
    const todayIdx = nDays - 4; // "today" is near the end so buckets fit
    const startDate = addDays(TODAY, -todayIdx);
    const rngDaily = seededRandom(555);
    const dailyActuals = [];
    const dailyForecasts = [];
    let dv = 100;

    for (let i = 0; i < nDays; i++) {
      dv += (rngDaily() - 0.48) * 6 + 0.5;
      dv = Math.max(dv, 40);
      const actual = Math.round(dv * 10) / 10;
      dailyActuals.push(actual);
      const horizonFactor = H / 7;
      const forecast = actual + (rngDaily() - 0.5) * 10 * horizonFactor;
      dailyForecasts.push(Math.round(forecast * 10) / 10);
    }
    const maxVersionIdx = todayIdx - H + 1;
    const versions = [];
    for (let vi = Math.max(0, maxVersionIdx - 15); vi <= maxVersionIdx; vi++) {
      versions.push(vi);
    }

    d3.select("#version-slider").attr("max", versions.length - 1);
    const clampedIdx = Math.min(versionIdx, versions.length - 1);
    const currentVersionIdx = versions[clampedIdx];
    const versionDate = new Date(startDate.getTime() + currentVersionIdx * 86400000);
    const dvFmt = d3.timeFormat("%b %d");
    d3.select("#version-date-display").text(dvFmt(versionDate));

    // Compute TAE and Actuals for this version's bucket
    let tae = 0;
    let actualsSum = 0;
    for (let d = currentVersionIdx; d < currentVersionIdx + H && d < nDays; d++) {
      tae += Math.abs(dailyForecasts[d] - dailyActuals[d]);
      actualsSum += dailyActuals[d];
    }
    const versionMAPE = actualsSum > 0 ? (tae / actualsSum) * 100 : 0;
    const bucketEndDate = new Date(versionDate.getTime() + (H - 1) * 86400000);

    // Compute aggregate MAPEx across ALL versions for this horizon
    let totalTAE = 0;
    let totalActualsAll = 0;
    let versionCount = 0;
    for (let vi = Math.max(0, maxVersionIdx - 15); vi <= maxVersionIdx; vi++) {
      let vTAE = 0;
      let vAct = 0;
      for (let d = vi; d < vi + H && d < nDays; d++) {
        vTAE += Math.abs(dailyForecasts[d] - dailyActuals[d]);
        vAct += dailyActuals[d];
      }
      totalTAE += vTAE;
      totalActualsAll += vAct;
      versionCount++;
    }
    const aggregateMAPEx = totalActualsAll > 0 ? (totalTAE / totalActualsAll) * 100 : 0;

    d3.select("#version-stats").html(
      "<strong>Version " + dvFmt(versionDate) + ":</strong> Bucket [" + dvFmt(versionDate) + " \u2013 " + dvFmt(bucketEndDate) + "]<br>" +
      "TAE = " + tae.toFixed(1) + ", Actuals = " + actualsSum.toFixed(1) + ", MAPE = " + versionMAPE.toFixed(2) + "%" +
      "<br><strong style=\"color:var(--accent);\">Aggregate MAPEx (H=" + H + ", " + versionCount + " versions): " + aggregateMAPEx.toFixed(2) + "%</strong>"
    );

    // Draw chart with bucket highlighted
    const cw = container.node().getBoundingClientRect().width;
    const width = cw;
    const height = Math.min(300, cw * 0.45);
    const iw = width - dailyMargin.left - dailyMargin.right;
    const ih = height - dailyMargin.top - dailyMargin.bottom;

    const svg = container.append("svg")
      .attr("viewBox", "0 0 " + width + " " + height)
      .attr("preserveAspectRatio", "xMidYMid meet");

    const gd = svg.append("g").attr("transform", "translate(" + dailyMargin.left + "," + dailyMargin.top + ")");

    const dates = d3.range(nDays).map(i => new Date(startDate.getTime() + i * 86400000));
    const xd = d3.scaleTime().domain([dates[0], dates[nDays - 1]]).range([0, iw]);
    const yd = d3.scaleLinear().domain([30, d3.max(dailyActuals) + 10]).range([ih, 0]);

    // Highlight bucket region
    const bucketStart = dates[currentVersionIdx];
    const bucketEnd = dates[Math.min(currentVersionIdx + H - 1, nDays - 1)];
    gd.append("rect")
      .attr("x", xd(bucketStart))
      .attr("y", 0)
      .attr("width", xd(bucketEnd) - xd(bucketStart))
      .attr("height", ih)
      .attr("fill", "rgba(0,61,165,0.08)")
      .attr("stroke", accent)
      .attr("stroke-width", 1.5)
      .attr("stroke-dasharray", "4 3");

    // Axes
    gd.append("g").attr("transform", "translate(0," + ih + ")")
      .call(d3.axisBottom(xd).ticks(8).tickFormat(d3.timeFormat("%b %d")))
      .call(g => g.select(".domain").attr("stroke", border))
      .call(g => g.selectAll(".tick line").attr("stroke", border))
      .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.6rem"));

    gd.append("g")
      .call(d3.axisLeft(yd).ticks(5))
      .call(g => g.select(".domain").attr("stroke", border))
      .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.65rem"));

    // Grid
    gd.append("g")
      .call(d3.axisLeft(yd).ticks(5).tickSize(-iw).tickFormat(""))
      .call(g => g.select(".domain").remove())
      .call(g => g.selectAll(".tick line").attr("stroke", border).attr("stroke-opacity", 0.4));

    // Lines
    const dvLine = d3.line().x(function(d, i) { return xd(dates[i]); }).y(function(d) { return yd(d); }).curve(d3.curveMonotoneX);

    gd.append("path").datum(dailyActuals).attr("d", dvLine)
      .attr("fill", "none").attr("stroke", teal).attr("stroke-width", 2);

    gd.append("path").datum(dailyForecasts).attr("d", dvLine)
      .attr("fill", "none").attr("stroke", orange).attr("stroke-width", 1.5).attr("stroke-dasharray", "4 2");

    // Version date marker
    gd.append("line")
      .attr("x1", xd(versionDate)).attr("x2", xd(versionDate))
      .attr("y1", 0).attr("y2", ih)
      .attr("stroke", accent).attr("stroke-width", 2);

    gd.append("text")
      .attr("x", xd(versionDate))
      .attr("y", -5)
      .attr("text-anchor", "middle")
      .attr("fill", accent)
      .style("font-size", "0.7rem")
      .style("font-weight", "600")
      .text("Version Date");

    // Today marker
    if (todayIdx < nDays) {
      gd.append("line")
        .attr("x1", xd(dates[todayIdx])).attr("x2", xd(dates[todayIdx]))
        .attr("y1", 0).attr("y2", ih)
        .attr("stroke", red).attr("stroke-width", 1).attr("stroke-dasharray", "3 3");

      gd.append("text")
        .attr("x", xd(dates[todayIdx])).attr("y", -5)
        .attr("text-anchor", "middle").attr("fill", red)
        .style("font-size", "0.65rem").style("font-weight", "600")
        .text("Today");
    }
  }

  renderDailyVersionsChart();
  d3.select("#daily-horizon-select").on("change", renderDailyVersionsChart);
  d3.select("#version-slider").on("input", renderDailyVersionsChart);

  // Auto-play animation for Daily Versions
  var versionPlayTimer = null;
  d3.select("#version-play-btn").on("click", function() {
    var btn = d3.select(this);
    if (versionPlayTimer) {
      clearInterval(versionPlayTimer);
      versionPlayTimer = null;
      btn.classed("playing", false).text("Play");
      return;
    }
    btn.classed("playing", true).text("Pause");
    var slider = document.getElementById("version-slider");
    var maxVal = +slider.getAttribute("max");
    slider.value = 0;
    renderDailyVersionsChart();
    versionPlayTimer = setInterval(function() {
      var cur = +slider.value;
      if (cur >= maxVal) {
        clearInterval(versionPlayTimer);
        versionPlayTimer = null;
        btn.classed("playing", false).text("Play");
        return;
      }
      slider.value = cur + 1;
      renderDailyVersionsChart();
    }, 600);
  });

  /* ═══════════════════════════════════════
     3c) Forecast Revision Impact Grid
     ═══════════════════════════════════════ */
  function renderImpactGrid() {
    const tbody = d3.select("#impact-body");
    tbody.selectAll("*").remove();

    const weeks = ["Week 1", "Week 2", "Week 3", "Week 4"];
    const horizons = [7, 14, 21, 28, 35];

    const impactMap = {
      "Week 1": { 7: "M", 14: "M", 21: "M", 28: "M+1", 35: "M+1" },
      "Week 2": { 7: "M", 14: "M", 21: "M, M+1", 28: "M+1", 35: "M+1, M+2" },
      "Week 3": { 7: "M", 14: "M", 21: "M+1", 28: "M+1", 35: "M+2" },
      "Week 4": { 7: "M", 14: "M, M+1", 21: "M+1", 28: "M+1", 35: "M+2" }
    };

    weeks.forEach(function(week) {
      const tr = tbody.append("tr");
      tr.append("td").text(week).style("font-weight", "600");

      horizons.forEach(function(h) {
        const impact = impactMap[week][h];
        const td = tr.append("td").text(impact);

        if (impact === "M") td.attr("class", "current-month");
        else if (impact.indexOf(",") >= 0) td.attr("class", "both-months");
        else td.attr("class", "next-month");

        td.on("click", function() {
          const rngImpact = seededRandom(week.charCodeAt(5) * 100 + h);
          const improvement = (rngImpact() * 3 + 1).toFixed(2);
          d3.select("#impact-result")
            .style("display", "block")
            .html("<strong>Editing " + week + " forecasts improves H=" + h + " MAPE by " + improvement + "%</strong><br>" +
                  "<span style=\"font-size:0.8rem;\">Affected periods: " + impact + "</span>");
        });
      });
    });
  }

  renderImpactGrid();

  /* ═══════════════════════════════════════
     4) Benchmark / Interpretation Chart
     ═══════════════════════════════════════ */
  (function () {
    const benchmarks = [
      { label: "Excellent", range: "< 10%", lo: 0, hi: 10, color: "#16a34a" },
      { label: "Good", range: "10–20%", lo: 10, hi: 20, color: "#65a30d" },
      { label: "Reasonable", range: "20–30%", lo: 20, hi: 30, color: "#eab308" },
      { label: "Poor", range: "30–50%", lo: 30, hi: 50, color: "#f97316" },
      { label: "Inaccurate", range: "> 50%", lo: 50, hi: 70, color: "#dc2626" },
    ];

    const container = d3.select("#benchmark-chart");
    const cw = container.node().getBoundingClientRect().width;
    const width = cw;
    const height = 180;
    const margin = { top: 15, right: 20, bottom: 30, left: 90 };
    const iw = width - margin.left - margin.right;
    const ih = height - margin.top - margin.bottom;

    const svg = container.append("svg")
      .attr("viewBox", `0 0 ${width} ${height}`)
      .attr("preserveAspectRatio", "xMidYMid meet");

    const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

    const y = d3.scaleBand().domain(benchmarks.map(d => d.label)).range([0, ih]).padding(0.3);
    const x = d3.scaleLinear().domain([0, 70]).range([0, iw]);

    g.append("g")
      .call(d3.axisBottom(x).ticks(7).tickFormat(d => d + "%"))
      .attr("transform", `translate(0,${ih})`)
      .call(g => g.select(".domain").attr("stroke", border))
      .call(g => g.selectAll(".tick line").attr("stroke", border))
      .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.65rem"));

    g.append("g")
      .call(d3.axisLeft(y))
      .call(g => g.select(".domain").remove())
      .call(g => g.selectAll(".tick line").remove())
      .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.72rem").style("font-weight", "600"));

    g.selectAll(".bench-bar").data(benchmarks).enter()
      .append("rect")
      .attr("x", d => x(d.lo)).attr("y", d => y(d.label))
      .attr("width", 0).attr("height", y.bandwidth())
      .attr("rx", 4).attr("fill", d => d.color).attr("opacity", 0.8)
      .transition().duration(700).delay((d, i) => i * 80)
      .attr("width", d => x(d.hi) - x(d.lo));

    g.selectAll(".bench-label").data(benchmarks).enter()
      .append("text")
      .attr("x", d => x(d.hi) + 6)
      .attr("y", d => y(d.label) + y.bandwidth() / 2)
      .attr("dy", "0.35em").attr("fill", textMuted)
      .style("font-size", "0.65rem").style("font-family", "var(--mono)")
      .text(d => d.range);
  })();

  /* ═══════════════════════════════════════
     5) CSV Upload — custom MAPEx
     ═══════════════════════════════════════ */
  function parseCSV(text) {
    const lines = text.trim().split(/\r?\n/);
    if (lines.length < 2) return null;
    const headers = lines[0].toLowerCase().split(",").map(h => h.trim());
    const ai = headers.indexOf("actual");
    const fi = headers.indexOf("forecast");
    const hi = headers.indexOf("horizon");
    if (ai === -1 || fi === -1) return null;

    const rows = [];
    for (let i = 1; i < lines.length; i++) {
      const cols = lines[i].split(",").map(c => c.trim());
      if (!cols[ai] || !cols[fi]) continue;
      const row = { actual: +cols[ai], forecast: +cols[fi] };
      if (hi !== -1 && cols[hi]) row.horizon = +cols[hi];
      if (!isNaN(row.actual) && !isNaN(row.forecast)) rows.push(row);
    }
    return rows.length > 0 ? rows : null;
  }

  function renderCSVResult(rows) {
    const resultDiv = d3.select("#csv-result");
    resultDiv.style("display", "block");
    d3.select("#csv-mapex-chart").selectAll("*").remove();

    const hasHorizon = rows[0].horizon !== undefined;

    if (hasHorizon) {
      // Group by horizon and compute MAPE for each
      const grouped = d3.group(rows, d => d.horizon);
      const mapexData = [];
      grouped.forEach((vals, h) => {
        const act = vals.map(v => v.actual);
        const pred = vals.map(v => v.forecast);
        mapexData.push({ horizon: h, mape: computeMAPE(act, pred) });
      });
      mapexData.sort((a, b) => a.horizon - b.horizon);

      const overallAct = rows.map(r => r.actual);
      const overallPred = rows.map(r => r.forecast);
      const overallMape = computeMAPE(overallAct, overallPred);
      d3.select("#csv-mape-result").text("Overall MAPEx Error = " + (overallMape === Infinity ? "Error: Forecast with zero actuals" : overallMape.toFixed(2) + "%"));

      // Draw MAPEx bar chart
      const container = d3.select("#csv-mapex-chart");
      const cw = container.node().getBoundingClientRect().width;
      const width = cw;
      const height = Math.min(300, cw * 0.5);
      const margin = { top: 20, right: 20, bottom: 40, left: 55 };
      const iw = width - margin.left - margin.right;
      const ih = height - margin.top - margin.bottom;

      const svg = container.append("svg")
        .attr("viewBox", `0 0 ${width} ${height}`)
        .attr("preserveAspectRatio", "xMidYMid meet");

      const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

      const x = d3.scaleBand().domain(mapexData.map(d => d.horizon)).range([0, iw]).padding(0.35);
      const yMax = d3.max(mapexData, d => d.mape) * 1.15;
      const y = d3.scaleLinear().domain([0, yMax]).range([ih, 0]);

      const colorScale = d3.scaleSequential()
        .domain([0, yMax]).interpolator(d3.interpolateRgb(accent, orange));

      g.append("g").attr("transform", `translate(0,${ih})`)
        .call(d3.axisBottom(x).tickFormat(d => d + "d"))
        .call(g => g.select(".domain").attr("stroke", border))
        .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.65rem"));

      g.append("g")
        .call(d3.axisLeft(y).ticks(5).tickFormat(d => d.toFixed(0) + "%"))
        .call(g => g.select(".domain").attr("stroke", border))
        .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.65rem"));

      g.append("g")
        .call(d3.axisLeft(y).ticks(5).tickSize(-iw).tickFormat(""))
        .call(g => g.select(".domain").remove())
        .call(g => g.selectAll(".tick line").attr("stroke", border).attr("stroke-opacity", 0.5));

      g.selectAll(".csv-bar").data(mapexData).enter()
        .append("rect")
        .attr("x", d => x(d.horizon)).attr("width", x.bandwidth())
        .attr("y", ih).attr("height", 0).attr("rx", 4)
        .attr("fill", d => colorScale(d.mape))
        .on("mouseover", function(evt, d) {
          showTooltip(evt, `Horizon: ${d.horizon} days<br>MAPE: ${d.mape.toFixed(2)}%`);
        })
        .on("mouseout", hideTooltip)
        .transition().duration(600).delay((d, i) => i * 60)
        .attr("y", d => y(d.mape)).attr("height", d => ih - y(d.mape));

      g.selectAll(".csv-label").data(mapexData).enter()
        .append("text")
        .attr("x", d => x(d.horizon) + x.bandwidth() / 2)
        .attr("y", d => y(d.mape) - 6)
        .attr("text-anchor", "middle").attr("fill", textMuted)
        .style("font-size", "0.6rem").style("font-family", "var(--mono)")
        .text(d => d.mape.toFixed(1) + "%");

    } else {
      // No horizon column — just show overall MAPE
      const act = rows.map(r => r.actual);
      const pred = rows.map(r => r.forecast);
      const mape = computeMAPE(act, pred);
      d3.select("#csv-mape-result").text("MAPEx Error = " + (mape === Infinity ? "Error: Forecast with zero actuals" : mape.toFixed(2) + "% (" + rows.length + " rows)"));
      d3.select("#csv-mapex-chart").append("p")
        .attr("class", "muted")
        .style("text-align", "center").style("font-size", "0.82rem")
        .text("Add a \"horizon\" column (e.g. 7, 14, 21, 28, 35) to see a MAPEx curve.");
    }
  }

  // File upload handler
  d3.select("#csv-upload").on("change", function () {
    const file = this.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function (e) {
      const rows = parseCSV(e.target.result);
      if (!rows) {
        d3.select("#csv-status").text("Could not parse CSV. Ensure it has \"actual\" and \"forecast\" columns.");
        d3.select("#csv-result").style("display", "none");
        return;
      }
      d3.select("#csv-status").text("Loaded " + rows.length + " rows from " + file.name);
      renderCSVResult(rows);
    };
    reader.readAsText(file);
  });

  // Sample data button
  d3.select("#csv-sample-btn").on("click", function () {
    const sampleCSV = [
      "actual,forecast,horizon",
      "100,97,7", "120,115,7", "90,88,7", "110,108,7", "105,101,7",
      "100,92,14", "120,110,14", "90,82,14", "110,100,14", "105,95,14",
      "100,88,21", "120,105,21", "90,78,21", "110,95,21", "105,90,21",
      "100,82,28", "120,98,28", "90,72,28", "110,88,28", "105,84,28",
      "100,75,35", "120,92,35", "90,68,35", "110,82,35", "105,78,35"
    ].join("\n");
    const rows = parseCSV(sampleCSV);
    d3.select("#csv-status").text("Loaded sample data (25 rows across 5 horizons)");
    renderCSVResult(rows);
  });

  /* ═══════════════════════════════════════
     6) Horizon Lag Visualization
     ═══════════════════════════════════════ */
  (function () {
    const container = d3.select("#lag-chart");
    const cw = container.node().getBoundingClientRect().width;
    const width = cw;
    const height = Math.min(320, cw * 0.5);
    const margin = { top: 25, right: 30, bottom: 35, left: 55 };
    const iw = width - margin.left - margin.right;
    const ih = height - margin.top - margin.bottom;

    const svg = container.append("svg")
      .attr("viewBox", `0 0 ${width} ${height}`)
      .attr("preserveAspectRatio", "xMidYMid meet");

    const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

    // Generate a synthetic daily series: 25 days before today + 35 days after
    const rngL = seededRandom(99);
    const daysBefore = 25;
    const daysAfter = 36; // enough to cover max horizon (35d)
    const nDays = daysBefore + daysAfter;
    const series = [];
    let sv = 100;
    for (let i = 0; i < nDays; i++) {
      sv += (rngL() - 0.48) * 5 + 0.2;
      sv = Math.max(sv, 30);
      series.push(sv);
    }

    const todayLag = daysBefore; // index of "today" in the series
    const lagStartDate = addDays(TODAY, -daysBefore);
    const lagDates = d3.range(nDays).map(function(i) { return addDays(lagStartDate, i); });

    const x = d3.scaleTime().domain([lagDates[0], lagDates[nDays - 1]]).range([0, iw]);
    const y = d3.scaleLinear().domain([d3.min(series) - 5, d3.max(series) + 10]).range([ih, 0]);

    // X axis with real dates — show Today + each horizon target date
    var lagTickDates = [TODAY].concat(HORIZONS.map(function(h) { return addDays(TODAY, h); }));
    g.append("g").attr("transform", `translate(0,${ih})`)
      .call(d3.axisBottom(x).tickValues(lagTickDates).tickFormat(d3.timeFormat("%b %d")))
      .call(g => g.select(".domain").attr("stroke", border))
      .call(g => g.selectAll(".tick line").attr("stroke", border))
      .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.55rem"));

    // Y axis
    g.append("g")
      .call(d3.axisLeft(y).ticks(5))
      .call(g => g.select(".domain").attr("stroke", border))
      .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.6rem"));

    // Grid
    g.append("g")
      .call(d3.axisLeft(y).ticks(5).tickSize(-iw).tickFormat(""))
      .call(g => g.select(".domain").remove())
      .call(g => g.selectAll(".tick line").attr("stroke", border).attr("stroke-opacity", 0.4));

    // Known data (up to "today")
    const knownData = series.slice(0, todayLag + 1);
    const knownDates = lagDates.slice(0, todayLag + 1);
    const lineGen = d3.line().x(function(d, i) { return x(knownDates[i]); }).y(function(d) { return y(d); }).curve(d3.curveMonotoneX);

    g.append("path").datum(knownData).attr("d", lineGen)
      .attr("fill", "none").attr("stroke", teal).attr("stroke-width", 2.5);

    // "Today" vertical line
    g.append("line")
      .attr("x1", x(TODAY)).attr("x2", x(TODAY))
      .attr("y1", 0).attr("y2", ih)
      .attr("stroke", accent).attr("stroke-width", 1.5).attr("stroke-dasharray", "4 3");

    g.append("text")
      .attr("x", x(TODAY)).attr("y", -8)
      .attr("text-anchor", "middle").attr("fill", accent)
      .style("font-size", "0.7rem").style("font-weight", "600").text("Today (" + fmt(TODAY) + ")");

    // For each horizon, draw the lag gap and prediction point
    const horizonColors = ["#16a34a", "#2563eb", "#8b5cf6", "#ea580c", "#dc2626"];

    HORIZONS.forEach(function(h, idx) {
      const targetDayIdx = todayLag + h;
      if (targetDayIdx >= nDays) return;

      const targetDate = lagDates[targetDayIdx];
      const targetVal = series[targetDayIdx];
      const color = horizonColors[idx];

      // Dashed lag line
      g.append("line")
        .attr("x1", x(TODAY)).attr("x2", x(targetDate))
        .attr("y1", y(targetVal)).attr("y2", y(targetVal))
        .attr("stroke", color).attr("stroke-width", 1.5)
        .attr("stroke-dasharray", "3 3").attr("opacity", 0.7);

      // Prediction target dot
      g.append("circle")
        .attr("cx", x(targetDate)).attr("cy", y(targetVal))
        .attr("r", 5).attr("fill", color).attr("stroke", "#fff").attr("stroke-width", 1.5);

      // Future series (faded)
      const futureSlice = series.slice(todayLag, targetDayIdx + 1);
      const futureDates = lagDates.slice(todayLag, targetDayIdx + 1);
      const futureLine = d3.line()
        .x(function(d, i) { return x(futureDates[i]); })
        .y(function(d) { return y(d); })
        .curve(d3.curveMonotoneX);

      g.append("path").datum(futureSlice).attr("d", futureLine)
        .attr("fill", "none").attr("stroke", color)
        .attr("stroke-width", 1).attr("stroke-dasharray", "2 3").attr("opacity", 0.35);

      // Horizon label with date
      g.append("text")
        .attr("x", x(targetDate) + 6).attr("y", y(targetVal) + 4)
        .attr("fill", color).style("font-size", "0.6rem").style("font-weight", "600")
        .text(h + "d (" + fmt(targetDate) + ")");
    });

    // Shaded "known" region
    const knownArea = d3.area()
      .x(function(d, i) { return x(knownDates[i]); })
      .y0(ih)
      .y1(function(d) { return y(d); })
      .curve(d3.curveMonotoneX);

    g.insert("path", ":first-child").datum(knownData).attr("d", knownArea)
      .attr("fill", teal).attr("opacity", 0.06);

  })();

  /* ═══════════════════════════════════════
     7) Bias Chart — Signed Error by Horizon
     ═══════════════════════════════════════ */
  function renderBiasChart(noise, trend, scenario) {
    var container = d3.select("#bias-chart");
    container.selectAll("*").remove();
    var sc = scenarios[scenario] || scenarios.stable;
    var N2 = 60;

    var biasData = HORIZONS.map(function(H) {
      var rng3 = seededRandom(77);
      var act2 = [];
      var v = 100;
      for (var i = 0; i < N2; i++) {
        v = sc(rng3, i, v);
        v += (rng3() - 0.5) * noise * 1.5 + trend * 0.3;
        v = Math.max(v, 20);
        act2.push(Math.round(v * 10) / 10);
      }
      var rng4 = seededRandom(200 + H);
      var signedErrors = [];
      for (var idx = 0; idx < act2.length; idx++) {
        var factor = H / 7;
        var n = (rng4() - 0.5) * 2 * factor * noise * 0.6;
        var d = factor * trend * 0.15 * (rng4() - 0.4);
        var pred = act2[idx] + n + d;
        signedErrors.push(((pred - act2[idx]) / act2[idx]) * 100);
      }
      var meanBias = d3.mean(signedErrors);
      return { horizon: H, bias: meanBias };
    });

    var cw = container.node().getBoundingClientRect().width;
    var width = cw;
    var height = Math.min(280, cw * 0.45);
    var margin = { top: 20, right: 30, bottom: 40, left: 55 };
    var iw = width - margin.left - margin.right;
    var ih = height - margin.top - margin.bottom;

    var svg = container.append("svg")
      .attr("viewBox", "0 0 " + width + " " + height)
      .attr("preserveAspectRatio", "xMidYMid meet");

    var g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    var allBias = biasData.map(function(d) { return Math.abs(d.bias); });
    var yExtent = d3.max(allBias) * 1.3;

    var x = d3.scaleBand().domain(HORIZONS).range([0, iw]).padding(0.3);
    var y = d3.scaleLinear().domain([-yExtent, yExtent]).range([ih, 0]);

    g.append("g").attr("transform", "translate(0," + ih + ")")
      .call(d3.axisBottom(x).tickFormat(function(d) { return d + "d"; }))
      .call(function(g) { g.select(".domain").attr("stroke", border); })
      .call(function(g) { g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.65rem"); });

    g.append("g")
      .call(d3.axisLeft(y).ticks(6).tickFormat(function(d) { return d.toFixed(0) + "%"; }))
      .call(function(g) { g.select(".domain").attr("stroke", border); })
      .call(function(g) { g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.65rem"); });

    // Zero line
    g.append("line")
      .attr("x1", 0).attr("x2", iw)
      .attr("y1", y(0)).attr("y2", y(0))
      .attr("stroke", border).attr("stroke-width", 2);

    // Bars
    g.selectAll(".bias-bar").data(biasData).enter()
      .append("rect")
      .attr("x", function(d) { return x(d.horizon); })
      .attr("width", x.bandwidth())
      .attr("y", function(d) { return d.bias >= 0 ? y(d.bias) : y(0); })
      .attr("height", function(d) { return Math.abs(y(d.bias) - y(0)); })
      .attr("rx", 4)
      .attr("fill", function(d) { return d.bias >= 0 ? orange : teal; })
      .attr("opacity", 0.8)
      .on("mouseover", function(evt, d) {
        showTooltip(evt, "H=" + d.horizon + "d<br>Mean bias: " + (d.bias >= 0 ? "+" : "") + d.bias.toFixed(2) + "%<br>" + (d.bias >= 0 ? "Over-forecasting" : "Under-forecasting"));
      })
      .on("mouseout", hideTooltip);

    // Value labels
    g.selectAll(".bias-label").data(biasData).enter()
      .append("text")
      .attr("x", function(d) { return x(d.horizon) + x.bandwidth() / 2; })
      .attr("y", function(d) { return d.bias >= 0 ? y(d.bias) - 6 : y(d.bias) + 14; })
      .attr("text-anchor", "middle").attr("fill", textMuted)
      .style("font-size", "0.6rem").style("font-family", "var(--mono)")
      .text(function(d) { return (d.bias >= 0 ? "+" : "") + d.bias.toFixed(1) + "%"; });

    // Summary
    var avgBias = d3.mean(biasData, function(d) { return d.bias; });
    var biasDir = avgBias >= 0 ? "over-forecasting" : "under-forecasting";
    d3.select("#bias-summary").html(
      "Average bias: <strong>" + (avgBias >= 0 ? "+" : "") + avgBias.toFixed(2) + "%</strong> (" + biasDir + ")"
    );
  }

  /* ═══════════════════════════════════════
     9) Weekly Forecast Change MAPEx Impact
     ═══════════════════════════════════════ */
  function renderWeeklyHeatmap() {
    var tbody = d3.select("#weekly-heatmap-body");
    tbody.selectAll("*").remove();

    var revisionPct = +d3.select("#revision-size-slider").property("value");
    d3.select("#revision-size-value").text(revisionPct + "%");

    var weeks = [
      { label: "Week 1 (" + fmt(TODAY) + ")", weekStart: 0 },
      { label: "Week 2 (" + fmt(addDays(TODAY, 7)) + ")", weekStart: 7 },
      { label: "Week 3 (" + fmt(addDays(TODAY, 14)) + ")", weekStart: 14 },
      { label: "Week 4 (" + fmt(addDays(TODAY, 21)) + ")", weekStart: 21 }
    ];

    // Simulate: revising forecasts in each week affects horizons differently
    // The logic: if you improve week W forecasts, horizon H is affected
    // proportional to how much of the H-day bucket overlaps with that week
    weeks.forEach(function(week) {
      var tr = tbody.append("tr");
      tr.append("td").text(week.label).style("font-weight", "600").style("font-size", "0.72rem");

      HORIZONS.forEach(function(H) {
        // Days in the horizon bucket that overlap with this week
        var overlapDays = 0;
        for (var d = 0; d < H; d++) {
          var dayInFuture = d;
          if (dayInFuture >= week.weekStart && dayInFuture < week.weekStart + 7) {
            overlapDays++;
          }
        }

        var overlapFraction = overlapDays / H;
        // MAPEx improvement = revision% * overlap fraction * decay factor
        var decayFactor = 1 / (1 + week.weekStart / 14); // further weeks have less impact
        var improvement = revisionPct * overlapFraction * decayFactor;

        var intensity = Math.min(improvement / (revisionPct * 0.8), 1);
        var bgColor = "rgba(22,163,74," + (intensity * 0.35) + ")"; // green

        var td = tr.append("td")
          .text(improvement > 0.01 ? "-" + improvement.toFixed(2) + "%" : "--")
          .style("background", bgColor)
          .style("color", improvement > 0.01 ? green : textMuted);

        td.on("mouseover", function(evt) {
          showTooltip(evt,
            "Revising " + week.label + " forecasts by " + revisionPct + "%<br>" +
            "Horizon: " + H + " days<br>" +
            "Overlap: " + overlapDays + "/" + H + " days (" + (overlapFraction * 100).toFixed(0) + "%)<br>" +
            "MAPEx improvement: " + (improvement > 0.01 ? "-" + improvement.toFixed(2) + "%" : "negligible")
          );
        }).on("mouseout", hideTooltip);

        td.on("click", function() {
          d3.select("#weekly-heatmap-detail")
            .style("display", "block")
            .html(
              "<strong>Revising Week " + ((week.weekStart / 7) + 1) + " forecasts (" + fmt(addDays(TODAY, week.weekStart)) + " \u2013 " + fmt(addDays(TODAY, week.weekStart + 6)) + ")</strong><br>" +
              "At H=" + H + "d: " + overlapDays + " of " + H + " days overlap (" + (overlapFraction * 100).toFixed(0) + "%), " +
              "expected MAPEx improvement: <strong style='color:" + green + "'>" + (improvement > 0.01 ? "-" + improvement.toFixed(2) + "%" : "negligible") + "</strong>"
            );
        });
      });
    });
  }

  renderWeeklyHeatmap();
  d3.select("#revision-size-slider").on("input", renderWeeklyHeatmap);

  /* ═══════════════════════════════════════
     10) Re-forecast Frequency Guide
     ═══════════════════════════════════════ */
  function renderReforecastGuide(mapexData) {
    if (!mapexData || mapexData.length < 2) return;

    var container = d3.select("#reforecast-chart");
    container.selectAll("*").remove();

    // Compute marginal increase between consecutive horizons
    var marginals = [];
    for (var i = 1; i < mapexData.length; i++) {
      var increase = mapexData[i].mape - mapexData[i - 1].mape;
      var perDay = increase / (mapexData[i].horizon - mapexData[i - 1].horizon);
      marginals.push({
        from: mapexData[i - 1].horizon,
        to: mapexData[i].horizon,
        label: mapexData[i - 1].horizon + "d\u2192" + mapexData[i].horizon + "d",
        increase: increase,
        perDay: perDay
      });
    }

    var cw = container.node().getBoundingClientRect().width;
    var width = cw;
    var height = Math.min(260, cw * 0.4);
    var margin = { top: 20, right: 30, bottom: 40, left: 55 };
    var iw = width - margin.left - margin.right;
    var ih = height - margin.top - margin.bottom;

    var svg = container.append("svg")
      .attr("viewBox", "0 0 " + width + " " + height)
      .attr("preserveAspectRatio", "xMidYMid meet");

    var g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    var x = d3.scaleBand().domain(marginals.map(function(d) { return d.label; })).range([0, iw]).padding(0.3);
    var yMax = d3.max(marginals, function(d) { return d.increase; }) * 1.2;
    var y = d3.scaleLinear().domain([0, yMax]).range([ih, 0]);

    g.append("g").attr("transform", "translate(0," + ih + ")")
      .call(d3.axisBottom(x))
      .call(function(g) { g.select(".domain").attr("stroke", border); })
      .call(function(g) { g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.6rem"); });

    g.append("g")
      .call(d3.axisLeft(y).ticks(5).tickFormat(function(d) { return "+" + d.toFixed(1) + "%"; }))
      .call(function(g) { g.select(".domain").attr("stroke", border); })
      .call(function(g) { g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.6rem"); });

    g.append("text").attr("transform", "rotate(-90)")
      .attr("x", -ih / 2).attr("y", -42)
      .attr("text-anchor", "middle").attr("fill", textMuted)
      .style("font-size", "0.68rem").text("Marginal MAPE Increase");

    // Grid
    g.append("g")
      .call(d3.axisLeft(y).ticks(5).tickSize(-iw).tickFormat(""))
      .call(function(g) { g.select(".domain").remove(); })
      .call(function(g) { g.selectAll(".tick line").attr("stroke", border).attr("stroke-opacity", 0.4); });

    // Color scale: steeper = more red/orange
    var barColor = d3.scaleSequential()
      .domain([0, yMax])
      .interpolator(d3.interpolateRgb(green, red));

    g.selectAll(".marginal-bar").data(marginals).enter()
      .append("rect")
      .attr("x", function(d) { return x(d.label); })
      .attr("width", x.bandwidth())
      .attr("y", function(d) { return y(d.increase); })
      .attr("height", function(d) { return ih - y(d.increase); })
      .attr("rx", 4)
      .attr("fill", function(d) { return barColor(d.increase); })
      .attr("opacity", 0.85)
      .on("mouseover", function(evt, d) {
        showTooltip(evt, d.label + "<br>MAPE increase: +" + d.increase.toFixed(2) + "%<br>Per day: +" + d.perDay.toFixed(3) + "%/day");
      })
      .on("mouseout", hideTooltip);

    g.selectAll(".marginal-label").data(marginals).enter()
      .append("text")
      .attr("x", function(d) { return x(d.label) + x.bandwidth() / 2; })
      .attr("y", function(d) { return y(d.increase) - 5; })
      .attr("text-anchor", "middle").attr("fill", textMuted)
      .style("font-size", "0.58rem").style("font-family", "var(--mono)")
      .text(function(d) { return "+" + d.increase.toFixed(1) + "%"; });

    // Generate recommendation
    var steepest = marginals.reduce(function(a, b) { return a.perDay > b.perDay ? a : b; });
    var flattest = marginals.reduce(function(a, b) { return a.perDay < b.perDay ? a : b; });
    var avgPerDay = d3.mean(marginals, function(d) { return d.perDay; });

    var recText = "";
    var recIcon = "";
    if (avgPerDay > 0.15) {
      recIcon = "&#9888;";
      recText = "Your MAPEx curve is <strong>steep</strong> (avg +" + avgPerDay.toFixed(2) + "%/day). " +
        "The steepest segment is <strong>" + steepest.label + "</strong> (+" + steepest.perDay.toFixed(3) + "%/day). " +
        "Consider <strong>daily or every-other-day</strong> re-forecasting to capture fast-moving changes.";
    } else if (avgPerDay > 0.05) {
      recIcon = "&#128337;";
      recText = "Your MAPEx curve has <strong>moderate slope</strong> (avg +" + avgPerDay.toFixed(2) + "%/day). " +
        "The steepest jump is at <strong>" + steepest.label + "</strong>. " +
        "<strong>Weekly</strong> re-forecasting should capture most error reduction.";
    } else {
      recIcon = "&#9989;";
      recText = "Your MAPEx curve is <strong>relatively flat</strong> (avg +" + avgPerDay.toFixed(2) + "%/day). " +
        "Even <strong>bi-weekly or monthly</strong> re-forecasting should keep error levels manageable. " +
        "The flattest segment: <strong>" + flattest.label + "</strong>.";
    }

    d3.select("#reforecast-recommendation").html(
      "<div class='rec-icon'>" + recIcon + "</div><div class='rec-text'>" + recText + "</div>"
    );
  }

  /* ═══════════════════════════════════════
     11) Responsive resize
     ═══════════════════════════════════════ */
  let resizeTimer;
  window.addEventListener("resize", () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => {
      renderTSChart();
      previousMapexData = null;
      renderMAPExChart();
      renderDailyVersionsChart();
      renderWeeklyHeatmap();
    }, 200);
  });

  /* ═══════════════════════════════════════
     8) KaTeX Formula Rendering
     ═══════════════════════════════════════ */
  function renderKaTeX() {
    var mapeEl = document.getElementById('mape-formula');
    var mapexEl = document.getElementById('mapex-formula-daily');
    var rfMain = document.getElementById('reforecast-formula-main');
    var rfInside = document.getElementById('reforecast-formula-inside');
    var rfOutside = document.getElementById('reforecast-formula-outside');

    if (typeof katex !== 'undefined') {
      if (mapeEl) {
        katex.render(
          String.raw`\text{MAPE} = \frac{100\%}{n} \times \sum_{t=1}^{n} \frac{|A_t - F_t|}{|A_t|}`,
          mapeEl,
          { displayMode: true, throwOnError: false }
        );
      }
      if (mapexEl) {
        katex.render(
          String.raw`\text{MAPEx}_H = \frac{\displaystyle\sum_{\text{all versions}} \text{TAE}_v}{\displaystyle\sum_{\text{all versions}} \text{Actuals}_v}`,
          mapexEl,
          { displayMode: true, throwOnError: false }
        );
      }
      if (rfMain) {
        katex.render(
          String.raw`\text{MAPEx}_H = \frac{\sum_V \text{TAE}_V}{\sum_V \text{Actuals}_V}, \qquad \text{TAE}_V = \sum_{d=V}^{V+H-1}\bigl|F_d^{(V)} - A_d\bigr|`,
          rfMain,
          { displayMode: true, throwOnError: false }
        );
      }
      if (rfInside) {
        katex.render(
          String.raw`d \in [V,\; V{+}H{-}1] \;\Rightarrow\; \Delta\text{MAPEx}_H = \frac{\bigl|F_d^{\text{new}} - A_d\bigr| - \bigl|F_d^{\text{old}} - A_d\bigr|}{\sum_V \text{Actuals}_V}`,
          rfInside,
          { displayMode: true, throwOnError: false }
        );
      }
      if (rfOutside) {
        katex.render(
          String.raw`d \notin [V,\; V{+}H{-}1] \;\Rightarrow\; \Delta\text{TAE}_V = 0 \;\Rightarrow\; \Delta\text{MAPEx}_H = 0`,
          rfOutside,
          { displayMode: true, throwOnError: false }
        );
      }
    }
  }

  // Wait for KaTeX to load then render
  if (typeof katex !== 'undefined') {
    renderKaTeX();
  } else {
    var katexScript = document.querySelector('script[src*="katex"]');
    if (katexScript) {
      katexScript.addEventListener('load', renderKaTeX);
    }
    // Fallback: poll for katex
    var katexPoll = setInterval(function() {
      if (typeof katex !== 'undefined') {
        clearInterval(katexPoll);
        renderKaTeX();
      }
    }, 100);
    setTimeout(function() { clearInterval(katexPoll); }, 5000);
  }

  /* ═══════════════════════════════════════
     9) Intersection observer for animations
     ═══════════════════════════════════════ */
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        entry.target.style.opacity = "1";
        entry.target.style.transform = "translateY(0)";
      }
    });
  }, { threshold: 0.15 });

  document.querySelectorAll(".vis-card, .step-card, .callout, .formula-card").forEach(el => {
    el.style.opacity = "0";
    el.style.transform = "translateY(20px)";
    el.style.transition = "opacity 0.6s ease, transform 0.6s ease";
    observer.observe(el);
  });

  /* ═══════════════════════════════════════
     10) Demand Generator — exposed update API
     ═══════════════════════════════════════ */
  window.updateMAPETable = function(newActuals, newForecasts) {
    // Replace in-place so closure bindings stay valid
    calcActuals = newActuals.slice(0, 5);
    calcForecasts = newForecasts.slice(0, 5);
    renderCalcTable();
  };

  window.updateActualVsForecastChart = function(newActuals) {
    actuals.length = 0;
    newActuals.forEach(function(a) { actuals.push(a); });
    renderTSChart();
  };

  window.updateMAPExChart = function() {
    previousMapexData = null;
    renderMAPExChart();
  };

  window.updateDailyVersionsViz = function() {
    renderDailyVersionsChart();
  };

  window.updateBiasChart = function() {
    renderBiasChart(FIXED_NOISE, FIXED_TREND, currentScenario);
  };

  window.updateHeatmap = function() {
    renderWeeklyHeatmap();
  };

})();
</script>

<!-- ══════════════ DEMAND GENERATOR WIRING ══════════════ -->
<script>
(function() {
  function fireRandomize() {
    var scenario = document.getElementById('scenario-select').value;
    var data = DemandGenerator.generate(scenario);

    // 1. MAPE calculator table
    if (typeof window.updateMAPETable === 'function') {
      window.updateMAPETable(data.actuals.slice(0, 5), data.forecasts[7].slice(0, 5));
    }
    // 2. Actual vs Forecast line chart
    if (typeof window.updateActualVsForecastChart === 'function') {
      window.updateActualVsForecastChart(data.actuals.slice(0, 30));
    }
    // 3. MAPEx scenario chart
    if (typeof window.updateMAPExChart === 'function') {
      window.updateMAPExChart();
    }
    // 4. Daily versions visualization
    if (typeof window.updateDailyVersionsViz === 'function') {
      window.updateDailyVersionsViz();
    }
    // 5. Bias chart
    if (typeof window.updateBiasChart === 'function') {
      window.updateBiasChart();
    }
    // 6. Weekly heatmap
    if (typeof window.updateHeatmap === 'function') {
      window.updateHeatmap();
    }

    // Seed display
    var seedEl = document.getElementById('seed-display');
    if (seedEl) seedEl.textContent = '#' + Math.floor(Math.random() * 9000 + 1000);

    // Flash button confirmation
    var btn = document.getElementById('randomize-btn');
    if (btn) {
      btn.textContent = '✓ Done';
      setTimeout(function() { btn.textContent = 'Randomize ↻'; }, 800);
    }
  }

  var btn = document.getElementById('randomize-btn');
  if (btn) btn.addEventListener('click', fireRandomize);

  var sel = document.getElementById('scenario-select');
  if (sel) sel.addEventListener('change', fireRandomize);
})();
</script>
</body>
</html>
