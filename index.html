<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MAPEx — Understanding Mean Absolute Percentage Error Over Forecast Horizons</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Source+Sans+3:wght@300;400;600;700&family=Source+Serif+4:opsz,wght@8..60,400;8..60,600;8..60,700&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
  <style>
    /* ── Reset & Base ── */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --bg: #fafaf9;
      --text: #1c1917;
      --text-muted: #57534e;
      --accent: #6d28d9;
      --accent-light: #ede9fe;
      --accent-mid: #a78bfa;
      --orange: #ea580c;
      --orange-light: #fff7ed;
      --teal: #0d9488;
      --teal-light: #f0fdfa;
      --red: #dc2626;
      --blue: #2563eb;
      --green: #16a34a;
      --border: #e7e5e4;
      --card-bg: #ffffff;
      --code-bg: #f5f5f4;
      --serif: 'Source Serif 4', Georgia, serif;
      --sans: 'Source Sans 3', system-ui, -apple-system, sans-serif;
      --mono: 'Fira Code', 'SF Mono', monospace;
      --max-w: 740px;
      --wide-max-w: 960px;
    }

    html { scroll-behavior: smooth; font-size: 18px; }

    body {
      font-family: var(--sans);
      background: var(--bg);
      color: var(--text);
      line-height: 1.7;
      -webkit-font-smoothing: antialiased;
    }

    /* ── Hero ── */
    .hero {
      text-align: center;
      padding: 5rem 2rem 4rem;
      background: linear-gradient(180deg, var(--accent-light) 0%, var(--bg) 100%);
      border-bottom: 1px solid var(--border);
    }

    .hero-badge {
      display: inline-block;
      background: var(--accent);
      color: #fff;
      font-size: 0.7rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      padding: 0.3em 1em;
      border-radius: 100px;
      margin-bottom: 1.5rem;
    }

    .hero h1 {
      font-family: var(--serif);
      font-size: clamp(2.4rem, 6vw, 3.6rem);
      font-weight: 700;
      line-height: 1.15;
      color: var(--text);
      max-width: 800px;
      margin: 0 auto 1rem;
    }

    .hero h1 span { color: var(--accent); }

    .hero p {
      font-size: 1.15rem;
      color: var(--text-muted);
      max-width: 560px;
      margin: 0 auto;
      line-height: 1.6;
    }

    /* ── Article body ── */
    .article { max-width: var(--max-w); margin: 0 auto; padding: 3rem 1.5rem 5rem; }

    .article h2 {
      font-family: var(--serif);
      font-size: 1.8rem;
      font-weight: 700;
      margin: 3.5rem 0 1rem;
      color: var(--text);
    }

    .article h3 {
      font-family: var(--serif);
      font-size: 1.3rem;
      font-weight: 600;
      margin: 2.5rem 0 0.75rem;
    }

    .article p { margin-bottom: 1.25rem; color: var(--text); }
    .article p.muted { color: var(--text-muted); font-size: 0.95rem; }

    .article a { color: var(--accent); text-decoration: underline; text-underline-offset: 2px; }
    .article a:hover { color: var(--orange); }

    .highlight { color: var(--accent); font-weight: 600; }
    .highlight-orange { color: var(--orange); font-weight: 600; }
    .highlight-teal { color: var(--teal); font-weight: 600; }

    /* ── Formula card ── */
    .formula-card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 2rem;
      margin: 1.5rem 0 2rem;
      text-align: center;
      box-shadow: 0 1px 3px rgba(0,0,0,0.04);
    }

    .formula-card .formula {
      font-family: var(--mono);
      font-size: 1.1rem;
      line-height: 2;
      color: var(--text);
    }

    .formula .f-var { color: var(--accent); font-weight: 500; }
    .formula .f-actual { color: var(--teal); font-weight: 500; }
    .formula .f-pred { color: var(--orange); font-weight: 500; }
    .formula .f-op { color: var(--text-muted); }

    .formula-card .formula-label {
      display: block;
      margin-top: 0.75rem;
      font-size: 0.8rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    /* ── Visualization containers ── */
    .vis-wide {
      max-width: var(--wide-max-w);
      margin: 2rem auto;
      padding: 0 1.5rem;
    }

    .vis-card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1.5rem 1.5rem 1rem;
      margin: 2rem 0;
      box-shadow: 0 1px 3px rgba(0,0,0,0.04);
      overflow: hidden;
    }

    .vis-card h4 {
      font-family: var(--sans);
      font-size: 0.8rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
      margin-bottom: 1rem;
    }

    .vis-card svg { display: block; width: 100%; height: auto; }

    /* ── Interactive controls ── */
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 1.25rem;
      align-items: center;
      margin-bottom: 1.25rem;
      padding: 1rem 1.25rem;
      background: var(--code-bg);
      border-radius: 8px;
    }

    .control-group { display: flex; flex-direction: column; gap: 0.3rem; }

    .control-group label {
      font-size: 0.72rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
    }

    .control-group .value-display {
      font-family: var(--mono);
      font-size: 0.85rem;
      font-weight: 500;
      color: var(--accent);
      min-width: 3ch;
    }

    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 180px;
      height: 6px;
      border-radius: 3px;
      background: var(--border);
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px; height: 18px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      border: 2px solid #fff;
      box-shadow: 0 1px 4px rgba(0,0,0,0.2);
    }

    input[type="range"]::-moz-range-thumb {
      width: 18px; height: 18px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      border: 2px solid #fff;
      box-shadow: 0 1px 4px rgba(0,0,0,0.2);
    }

    /* ── Callout boxes ── */
    .callout {
      border-left: 4px solid var(--accent);
      background: var(--accent-light);
      padding: 1rem 1.25rem;
      border-radius: 0 8px 8px 0;
      margin: 1.5rem 0;
      font-size: 0.95rem;
    }

    .callout.callout-orange {
      border-left-color: var(--orange);
      background: var(--orange-light);
    }

    .callout.callout-teal {
      border-left-color: var(--teal);
      background: var(--teal-light);
    }

    .callout strong { font-weight: 700; }

    /* ── Step-through / scrollytelling ── */
    .step-cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin: 1.5rem 0 2rem;
    }

    .step-card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 1.25rem;
      text-align: center;
      transition: border-color 0.2s, box-shadow 0.2s;
    }

    .step-card:hover {
      border-color: var(--accent-mid);
      box-shadow: 0 2px 8px rgba(109,40,217,0.08);
    }

    .step-card .step-num {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 2rem; height: 2rem;
      border-radius: 50%;
      background: var(--accent);
      color: #fff;
      font-size: 0.8rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
    }

    .step-card h5 {
      font-size: 0.95rem;
      font-weight: 600;
      margin-bottom: 0.35rem;
    }

    .step-card p {
      font-size: 0.82rem;
      color: var(--text-muted);
      margin: 0;
      line-height: 1.5;
    }

    /* ── Table for MAPE calculation ── */
    .calc-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
      margin: 1rem 0;
    }

    .calc-table th {
      background: var(--code-bg);
      font-weight: 600;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--text-muted);
      padding: 0.6rem 0.75rem;
      text-align: center;
      border-bottom: 2px solid var(--border);
    }

    .calc-table td {
      padding: 0.55rem 0.75rem;
      text-align: center;
      border-bottom: 1px solid var(--border);
      font-family: var(--mono);
      font-size: 0.85rem;
    }

    .calc-table tr:last-child td { border-bottom: none; }
    .calc-table .col-actual { color: var(--teal); font-weight: 500; }
    .calc-table .col-pred { color: var(--orange); font-weight: 500; }
    .calc-table .col-error { color: var(--red); font-weight: 500; }

    .mape-result {
      text-align: center;
      font-family: var(--mono);
      font-size: 1.4rem;
      font-weight: 700;
      color: var(--accent);
      padding: 0.75rem;
      background: var(--accent-light);
      border-radius: 8px;
      margin: 1rem 0;
    }

    /* ── Horizon bar chart colors ── */
    .horizon-bar { transition: all 0.3s ease; }
    .horizon-bar:hover { opacity: 0.85; }

    /* ── Tooltip ── */
    .tooltip {
      position: absolute;
      pointer-events: none;
      background: var(--text);
      color: #fff;
      padding: 0.4rem 0.65rem;
      border-radius: 6px;
      font-size: 0.78rem;
      font-family: var(--mono);
      line-height: 1.4;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      opacity: 0;
      transition: opacity 0.15s;
      z-index: 100;
      white-space: nowrap;
    }

    /* ── Legend ── */
    .legend {
      display: flex;
      gap: 1.5rem;
      flex-wrap: wrap;
      margin-bottom: 0.75rem;
      font-size: 0.8rem;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      color: var(--text-muted);
    }

    .legend-swatch {
      width: 12px; height: 12px;
      border-radius: 3px;
      flex-shrink: 0;
    }

    /* ── Animated dot ── */
    @keyframes pulse {
      0%, 100% { r: 4; opacity: 1; }
      50% { r: 7; opacity: 0.6; }
    }

    .pulse-dot { animation: pulse 2s ease-in-out infinite; }

    /* ── Divider ── */
    .divider {
      border: none;
      height: 1px;
      background: var(--border);
      margin: 3rem 0;
    }

    /* ── Footer ── */
    .footer {
      text-align: center;
      padding: 2.5rem 1.5rem;
      border-top: 1px solid var(--border);
      color: var(--text-muted);
      font-size: 0.82rem;
    }

    .footer a { color: var(--accent); text-decoration: none; }
    .footer a:hover { text-decoration: underline; }

    /* ── Impact table ── */
    .impact-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
      margin: 1rem 0;
    }

    .impact-table th {
      background: var(--code-bg);
      font-weight: 600;
      font-size: 0.7rem;
      text-transform: uppercase;
      padding: 0.6rem 0.5rem;
      text-align: center;
      border: 1px solid var(--border);
    }

    .impact-table td {
      padding: 0.75rem 0.5rem;
      text-align: center;
      border: 1px solid var(--border);
      cursor: pointer;
      transition: background 0.2s;
    }

    .impact-table td:hover {
      background: var(--accent-light);
    }

    .impact-table td.current-month {
      background: var(--teal-light);
      color: var(--teal);
      font-weight: 600;
    }

    .impact-table td.next-month {
      background: var(--orange-light);
      color: var(--orange);
      font-weight: 600;
    }

    .impact-table td.both-months {
      background: linear-gradient(135deg, var(--teal-light) 50%, var(--orange-light) 50%);
      color: var(--text);
      font-weight: 600;
    }

    /* ── Scenario toggle buttons ── */
    .scenario-btns {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
    }

    .scenario-btn {
      font-family: var(--sans);
      font-size: 0.75rem;
      font-weight: 600;
      padding: 0.45em 1em;
      border-radius: 100px;
      border: 1.5px solid var(--border);
      background: var(--card-bg);
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.2s;
    }

    .scenario-btn:hover { border-color: var(--accent-mid); color: var(--accent); }
    .scenario-btn.active { background: var(--accent); color: #fff; border-color: var(--accent); }

    /* ── Play button ── */
    .play-btn {
      font-family: var(--sans);
      font-size: 0.75rem;
      font-weight: 600;
      padding: 0.4em 1.2em;
      border-radius: 100px;
      border: 1.5px solid var(--accent);
      background: var(--accent-light);
      color: var(--accent);
      cursor: pointer;
      transition: all 0.2s;
    }
    .play-btn:hover { background: var(--accent); color: #fff; }
    .play-btn.playing { background: var(--orange); color: #fff; border-color: var(--orange); }

    /* ── Business impact card ── */
    .impact-result-card {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 0.75rem;
      margin: 1rem 0;
    }

    .impact-metric {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 1rem;
      text-align: center;
    }

    .impact-metric .metric-value {
      font-family: var(--mono);
      font-size: 1.3rem;
      font-weight: 700;
      color: var(--accent);
    }

    .impact-metric .metric-label {
      font-size: 0.7rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.06em;
      margin-top: 0.25rem;
    }

    /* ── Weekly change heatmap ── */
    .weekly-heatmap-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.82rem;
      margin: 1rem 0;
    }

    .weekly-heatmap-table th {
      background: var(--code-bg);
      font-weight: 600;
      font-size: 0.68rem;
      text-transform: uppercase;
      padding: 0.6rem 0.4rem;
      text-align: center;
      border: 1px solid var(--border);
    }

    .weekly-heatmap-table td {
      padding: 0.6rem 0.4rem;
      text-align: center;
      border: 1px solid var(--border);
      font-family: var(--mono);
      font-size: 0.78rem;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }

    .weekly-heatmap-table td:hover {
      outline: 2px solid var(--accent);
      outline-offset: -2px;
      z-index: 1;
    }

    /* ── Reforecast guide ── */
    .reforecast-recommendation {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 1.25rem;
      background: var(--accent-light);
      border: 1px solid var(--accent-mid);
      border-radius: 10px;
      margin: 1rem 0;
    }

    .reforecast-recommendation .rec-icon {
      font-size: 2rem;
      flex-shrink: 0;
    }

    .reforecast-recommendation .rec-text {
      font-size: 0.88rem;
      line-height: 1.5;
    }

    .reforecast-recommendation .rec-text strong {
      color: var(--accent);
    }

    /* ── Responsive ── */
    @media (max-width: 640px) {
      html { font-size: 16px; }
      .hero { padding: 3rem 1.25rem 2.5rem; }
      .article { padding: 2rem 1.25rem 3rem; }
      input[type="range"] { width: 140px; }
      .controls { gap: 0.75rem; padding: 0.75rem; }
      .step-cards { grid-template-columns: 1fr; }
      .scenario-btns { gap: 0.35rem; }
      .scenario-btn { font-size: 0.68rem; padding: 0.35em 0.8em; }
      .impact-result-card { grid-template-columns: 1fr 1fr; }
    }
  </style>
</head>
<body>

<!-- ══════════════ HERO ══════════════ -->
<header class="hero">
  <div class="hero-badge">Interactive Explainer</div>
  <h1>MAPE<span>x</span></h1>
  <p>A visual, interactive guide to <strong>Mean Absolute Percentage Error</strong> and how forecast accuracy changes across prediction horizons.</p>
</header>

<!-- ══════════════ ARTICLE ══════════════ -->
<main class="article">

  <!-- ── Section 1: What is Forecasting? ── -->
  <h2>Why Forecast Accuracy Matters</h2>
  <p>
    Organizations use forecasts to predict future demand, revenue, inventory needs, and more.
    A forecast is only useful if it's <em>accurate enough</em> to drive good decisions. But how
    do we measure "accurate enough"?
  </p>
  <p>
    One of the most widely used metrics is <span class="highlight">MAPE</span> — the
    <strong>Mean Absolute Percentage Error</strong>. It tells you, on average, how far off your
    predictions are from reality, expressed as a percentage.
  </p>

  <!-- ── Section 2: The MAPE Formula ── -->
  <h2>The MAPE Formula</h2>
  <p>MAPE is calculated in four intuitive steps:</p>

  <div class="step-cards">
    <div class="step-card">
      <div class="step-num">1</div>
      <h5>Error</h5>
      <p>Subtract the forecast from the actual value for each period.</p>
    </div>
    <div class="step-card">
      <div class="step-num">2</div>
      <h5>Absolute</h5>
      <p>Take the absolute value — we care about magnitude, not direction.</p>
    </div>
    <div class="step-card">
      <div class="step-num">3</div>
      <h5>Percentage</h5>
      <p>Divide by the actual value to get a relative error for each period.</p>
    </div>
    <div class="step-card">
      <div class="step-num">4</div>
      <h5>Mean</h5>
      <p>Average all the percentage errors across periods.</p>
    </div>
  </div>

  <div class="formula-card">
    <div class="formula" id="mape-formula"></div>
    <span class="formula-label">
      where <span class="f-actual">A<sub>t</sub></span> = actual value,
      <span class="f-pred">F<sub>t</sub></span> = forecast value,
      <span class="f-var">n</span> = number of periods
    </span>
  </div>

  <div class="callout callout-teal">
    <strong>Interpretation:</strong> A MAPE of 5% means your forecasts are, on average, 5% away from
    the actual values. Lower is better.
  </div>

  <!-- ── Section 3: Interactive MAPE Calculator ── -->
  <h2>See MAPE in Action</h2>
  <p>
    The table below shows a simple example. <strong>Drag the sliders</strong> to change the
    actual values and watch MAPE update in real time. The forecasts are held constant.
  </p>

  <div class="vis-card">
    <h4>Interactive MAPE Calculator</h4>
    <div id="calc-container">
      <table class="calc-table">
        <thead>
          <tr>
            <th>Period</th>
            <th>Actual (Aₜ) — drag to edit</th>
            <th>Forecast (Fₜ)</th>
            <th>|Aₜ − Fₜ| / |Aₜ|</th>
          </tr>
        </thead>
        <tbody id="calc-body"></tbody>
      </table>
      <div id="mape-result" class="mape-result"></div>
    </div>
  </div>

  <div class="callout callout-teal">
    <strong>Higher actuals help MAPE:</strong> When actual values increase but forecast errors
    stay the same in absolute terms, the percentage error decreases. For example, if forecast
    is off by 10 units: 10/100 = 10% error, but 10/200 = 5% error. MAPE is a relative metric,
    so larger denominators (actuals) reduce the percentage error.
  </div>

  <hr class="divider">

  <!-- ── Section 4: Understanding Horizon and Time Bucket ── -->
  <h2>Understanding Horizon and Time Bucket</h2>

  <div class="step-cards">
    <div class="step-card">
      <div class="step-num">1</div>
      <h5>Horizon (H days)</h5>
      <p>
        The period that includes all transactional activities from day 1 to day H.
        A 14-day horizon means forecasting for a consecutive 14-day window.
      </p>
    </div>
    <div class="step-card">
      <div class="step-num">2</div>
      <h5>Time Bucket</h5>
      <p>
        The aggregation period for estimates and actuals. For daily MAPEx,
        each version has a bucket [V, V+H&minus;1] over which we sum forecasts and actuals.
      </p>
    </div>
    <div class="step-card">
      <div class="step-num">3</div>
      <h5>Lag (Currently 0)</h5>
      <p>
        The delay between forecast generation and forecast period start.
        Lag=0 means forecasts generated on Monday cover Monday+H days.
        We use lag=0 for all MAPEx calculations.
      </p>
    </div>
  </div>

  <div class="callout">
    <strong>Example:</strong> On <span id="example-today"></span> with H=14 and lag=0, the forecast covers
    <span id="example-range-start"></span> &ndash; <span id="example-range-end"></span> (14 days). The time bucket = forecast period = [<span id="example-bucket-start"></span>, <span id="example-bucket-end"></span>].
  </div>

  <!-- ── Section 5: Interactive Time Series + Horizon ── -->
  <h2>Forecasts Across Horizons</h2>
  <p>
    The chart below shows actual values (solid line) and forecasts at different horizons.
    Use the slider to change the forecast horizon and observe how the predictions diverge from
    reality as we look further ahead.
  </p>

  <div class="vis-card">
    <h4>Actual vs. Forecast — Adjustable Horizon</h4>
    <div class="controls">
      <div class="control-group">
        <label>Forecast Horizon (x)</label>
        <div style="display:flex;align-items:center;gap:0.5rem;">
          <input type="range" id="horizon-slider" min="0" max="4" value="0" step="1">
          <span class="value-display" id="horizon-value">7</span>
          <span style="font-size:0.78rem;color:var(--text-muted);">days ahead</span>
        </div>
      </div>
    </div>
    <div class="legend">
      <div class="legend-item"><div class="legend-swatch" style="background:var(--teal)"></div> Actual</div>
      <div class="legend-item"><div class="legend-swatch" style="background:var(--orange)"></div> Forecast</div>
      <div class="legend-item"><div class="legend-swatch" style="background:rgba(234,88,12,0.15)"></div> Error region</div>
    </div>
    <div id="ts-chart"></div>
    <div id="ts-mape" class="mape-result" style="margin-top:0.75rem;"></div>
  </div>

  <hr class="divider">

  <!-- ── Section 6: MAPE vs Horizon ── -->
  <h2>MAPEx: Error Grows with Horizon</h2>
  <p>
    Now let's plot the MAPE <em>itself</em> for each horizon. This is the MAPEx curve — it shows
    how forecast quality degrades as we predict further into the future.
  </p>

  <div class="callout callout-teal" style="font-size:0.88rem;">
    <strong>Try it:</strong> Set noise to <strong>1</strong> vs <strong>8</strong> and see how the MAPEx curve changes. Higher noise shifts the entire curve upward.
  </div>

  <div class="vis-card">
    <h4>MAPEx — MAPE at Each Forecast Horizon</h4>
    <div class="legend" style="margin-bottom:0.5rem;">
      <div class="legend-item"><div class="legend-swatch" style="background:var(--accent)"></div> Model</div>
      <div class="legend-item"><div class="legend-swatch" style="background:#d4d4d4"></div> Previous (ghost)</div>
      <div class="legend-item"><div class="legend-swatch" style="background:var(--teal);opacity:0.5"></div> Naive baseline</div>
      <div class="legend-item"><div class="legend-swatch" style="background:rgba(109,40,217,0.1);border:1px dashed var(--accent-mid)"></div> P10&ndash;P90 band</div>
    </div>
    <p style="font-size:0.82rem;color:var(--text-muted);margin:0 0 0.75rem;">Choose a demand pattern to see how MAPEx behaves under different scenarios:</p>
    <div class="scenario-btns" id="scenario-btns">
      <button class="scenario-btn active" data-scenario="stable">Stable Demand</button>
      <button class="scenario-btn" data-scenario="seasonal">Seasonal</button>
      <button class="scenario-btn" data-scenario="spike">Promo Spike</button>
      <button class="scenario-btn" data-scenario="newproduct">New Product Launch</button>
    </div>
    <div class="controls">
      <div class="control-group">
        <label>Noise Level</label>
        <div style="display:flex;align-items:center;gap:0.5rem;">
          <input type="range" id="noise-slider" min="1" max="10" value="4" step="1">
          <span class="value-display" id="noise-value">4</span>
        </div>
      </div>
      <div class="control-group">
        <label>Trend Strength</label>
        <div style="display:flex;align-items:center;gap:0.5rem;">
          <input type="range" id="trend-slider" min="0" max="10" value="3" step="1">
          <span class="value-display" id="trend-value">3</span>
        </div>
      </div>
    </div>
    <div id="mapex-chart"></div>
  </div>

  <p class="muted" style="text-align:center;margin-top:0.5rem;">In this demo, we simulate a recursive model: each step uses the previous forecast as input, so errors accumulate.</p>

  <p>
    Notice the characteristic upward shape: short horizons produce small errors, while
    longer horizons produce progressively larger errors. The rate of increase depends on
    the <span class="highlight-orange">noise</span> in the data and the
    <span class="highlight-teal">trend strength</span>.
  </p>

  <hr class="divider">

  <!-- ── Daily Versions Section ── -->
  <h2>The MAPEx Formula &mdash; Daily Versions</h2>
  <p>
    The correct MAPEx formula uses a <strong>rolling daily version</strong> approach.
    For each day (version date), we create a forecast for the next H days and compare
    it to actual values once they're available.
  </p>

  <div class="formula-card">
    <div class="formula" id="mapex-formula-daily"></div>
    <span class="formula-label">
      where each version V has a time bucket [V, V+H&minus;1],<br>
      TAE<sub>v</sub> = &Sigma;|F<sub>d</sub> &minus; A<sub>d</sub>| for d &isin; bucket,
      Actuals<sub>v</sub> = &Sigma; A<sub>d</sub> for d &isin; bucket
    </span>
  </div>

  <h3>Daily Versions Explained</h3>
  <p>
    For <strong>today = <span id="dv-today"></span></strong> and <strong>horizon = 14 days</strong>:
  </p>
  <ul style="margin:0.75rem 0 1.25rem 1.5rem;color:var(--text);" id="dv-versions-list">
  </ul>
  <p id="dv-aggregate-text">
  </p>

  <div class="vis-card">
    <h4>Daily Versions Visualized &mdash; Rolling Windows</h4>
    <div class="controls">
      <div class="control-group">
        <label>Horizon (H)</label>
        <select id="daily-horizon-select" style="font-size:0.85rem;padding:0.3em 0.5em;border-radius:6px;border:1px solid var(--border);">
          <option value="7">7 days</option>
          <option value="14" selected>14 days</option>
          <option value="21">21 days</option>
          <option value="28">28 days</option>
          <option value="35">35 days</option>
        </select>
      </div>
      <div class="control-group">
        <label>Show Version</label>
        <div style="display:flex;align-items:center;gap:0.5rem;">
          <input type="range" id="version-slider" min="0" max="15" value="0" step="1">
          <span class="value-display" id="version-date-display">...</span>
          <button class="play-btn" id="version-play-btn">Play</button>
        </div>
      </div>
    </div>
    <div class="legend">
      <div class="legend-item"><div class="legend-swatch" style="background:var(--teal)"></div> Actual</div>
      <div class="legend-item"><div class="legend-swatch" style="background:var(--orange)"></div> Forecast</div>
      <div class="legend-item"><div class="legend-swatch" style="background:rgba(109,40,217,0.08);border:1px dashed var(--accent)"></div> Time Bucket</div>
    </div>
    <div id="daily-versions-chart"></div>
    <div class="mape-result" id="version-stats"></div>
  </div>

  <hr class="divider">

  <!-- ── Forecast Revision Impact Grid ── -->
  <h2>Forecast Revision Impact Across Horizons</h2>
  <p>
    When you edit a forecast in a specific week, it affects different horizon/month
    combinations. The table below shows which months are impacted for each horizon.
  </p>

  <div class="vis-card">
    <h4>Forecast Edit Impact Matrix</h4>
    <table class="impact-table" id="impact-table">
      <thead>
        <tr>
          <th>Editing Week</th>
          <th>H=7 Days</th>
          <th>H=14 Days</th>
          <th>H=21 Days</th>
          <th>H=28 Days</th>
          <th>H=35 Days</th>
        </tr>
      </thead>
      <tbody id="impact-body"></tbody>
    </table>
    <p class="muted" style="margin-top:1rem;text-align:center;">
      Click on a cell to see which months are affected by editing that week's forecast.
    </p>
    <div id="impact-result" class="mape-result" style="display:none;"></div>
  </div>

  <hr class="divider">

  <!-- ── Section 7: Why does error grow? ── -->
  <h2>Why Does Error Grow with Horizon?</h2>

  <div class="step-cards">
    <div class="step-card">
      <div class="step-num" style="background:var(--orange)">1</div>
      <h5>Error Accumulation</h5>
      <p>Recursive models feed predictions back as inputs. Small errors compound at each step.</p>
    </div>
    <div class="step-card">
      <div class="step-num" style="background:var(--orange)">2</div>
      <h5>Increasing Uncertainty</h5>
      <p>The further ahead we look, the more unforeseen events can occur. The future is fundamentally uncertain.</p>
    </div>
    <div class="step-card">
      <div class="step-num" style="background:var(--orange)">3</div>
      <h5>Signal Decay</h5>
      <p>Recent observations carry strong signal. As the horizon grows, the model must rely on weaker, older patterns.</p>
    </div>
  </div>

  <hr class="divider">

  <!-- ── Section 8: Interpreting MAPE ── -->
  <h2>Interpreting MAPE Values</h2>

  <div class="vis-card">
    <h4>MAPE Quality Benchmarks</h4>
    <div id="benchmark-chart"></div>
  </div>

  <p class="muted">
    These benchmarks are rough rules of thumb. What counts as "good" depends entirely on the
    domain — a 10% MAPE might be excellent for long-range energy demand forecasts but
    unacceptable for short-term stock predictions.
  </p>

  <hr class="divider">

  <!-- ── Section 9: Limitations ── -->
  <h2>Limitations of MAPE</h2>

  <div class="callout callout-orange">
    <strong>Division by zero:</strong> If any actual value Aₜ is zero, MAPE is undefined.
    This makes MAPE unsuitable for intermittent or sparse data.
  </div>

  <p>
    <strong>Asymmetric penalty:</strong> MAPE penalizes over-forecasts more heavily than
    under-forecasts. A forecast of 150 when actual is 100 gives 50% error, but a forecast
    of 50 when actual is 100 also gives 50%. However, there's no upper bound for over-forecasting
    errors while under-forecasting errors cap at 100%.
  </p>

  <p>
    <strong>Scale sensitivity at low volumes:</strong> If actual demand is 2 units and you forecast 1,
    the percentage error is 50% — despite only being off by a single unit.
  </p>

  <div class="callout callout-orange">
    <strong>Volume weighting across SKUs:</strong> When computing MAPEx across multiple SKUs
    (products), high-volume items dominate the aggregate MAPE since their absolute errors are
    larger. A single best-selling SKU can skew the overall MAPEx curve, masking poor performance
    on low-volume items. Consider computing MAPE per-SKU first, then averaging, or use WMAPE
    to explicitly weight by volume.
  </div>

  <hr class="divider">

  <!-- ── Section 10: Upload your own data ── -->
  <h2>Try Your Own Data</h2>
  <p>
    Upload a CSV with columns <code>actual</code> and <code>forecast</code> to compute your
    own MAPE. Optionally include a <code>horizon</code> column (e.g. 7, 14, 21, 28, 35) to
    see your own MAPEx curve.
  </p>

  <div class="vis-card">
    <h4>CSV Upload</h4>
    <div class="controls" style="flex-direction:column;align-items:flex-start;">
      <div style="display:flex;align-items:center;gap:1rem;flex-wrap:wrap;">
        <input type="file" id="csv-upload" accept=".csv" style="font-size:0.85rem;">
        <button id="csv-sample-btn" style="font-size:0.78rem;padding:0.4em 1em;border-radius:6px;border:1px solid var(--accent);background:var(--accent-light);color:var(--accent);cursor:pointer;font-weight:600;">Load sample data</button>
      </div>
      <p id="csv-status" class="muted" style="margin:0.5rem 0 0;font-size:0.8rem;"></p>
    </div>
    <div id="csv-result" style="display:none;">
      <div id="csv-mape-result" class="mape-result"></div>
      <div id="csv-mapex-chart" style="margin-top:1rem;"></div>
    </div>
  </div>

  <hr class="divider">

  <!-- ── Section 11: Horizon Lag Visualization ── -->
  <h2>Understanding Horizon Lag</h2>
  <p>
    When you forecast at horizon <span class="highlight-orange">x</span>, you're predicting
    the value <em>x days from now</em> using only data available <em>today</em>. The gap between
    the last known data point and the prediction target is the <strong>lag</strong>.
  </p>
  <p>
    The visualization below shows this for each horizon. The solid region is known data,
    the gap is the lag (the blind spot), and the point at the end is what the model must predict.
    As the horizon grows, the lag grows — and the model has less relevant information to work with.
  </p>

  <div class="vis-card">
    <h4>Horizon Lag — What the Model "Sees" vs. What It Must Predict</h4>
    <div id="lag-chart"></div>
  </div>

  <p>
    At <span class="highlight">day 7</span> (<span id="lag-date-7"></span>), the model predicts just one week out — the lag is
    short and recent patterns are still relevant. By <span class="highlight-orange">day 35</span>
    (<span id="lag-date-35"></span>), the model must bridge a five-week gap, during which demand patterns, seasonality, and external
    factors can all shift. This is why MAPEx increases with horizon.
  </p>

  <hr class="divider">

  <!-- ── Bias Visualization ── -->
  <h2>Forecast Bias by Horizon</h2>
  <p>
    MAPE measures absolute error, but it hides the <em>direction</em> of mistakes.
    The chart below shows the <strong>mean signed error</strong> at each horizon.
    Positive values mean the model over-forecasts (predicts too high);
    negative values mean it under-forecasts.
  </p>

  <div class="vis-card">
    <h4>Signed Forecast Error by Horizon</h4>
    <div class="legend" style="margin-bottom:0.5rem;">
      <div class="legend-item"><div class="legend-swatch" style="background:var(--orange)"></div> Over-forecast (+)</div>
      <div class="legend-item"><div class="legend-swatch" style="background:var(--teal)"></div> Under-forecast (&minus;)</div>
    </div>
    <div id="bias-chart"></div>
    <div id="bias-summary" class="mape-result" style="margin-top:0.75rem;font-size:1rem;"></div>
  </div>

  <hr class="divider">

  <!-- ── Business Impact Translator ── -->
  <h2>Business Impact Translator</h2>
  <p>
    MAPE percentages become meaningful when you translate them to dollars.
    Enter your monthly revenue below to see how forecast error at each horizon
    translates into potential inventory misallocation.
  </p>

  <div class="vis-card">
    <h4>MAPE to Dollar Impact</h4>
    <div class="controls">
      <div class="control-group">
        <label>Monthly Revenue ($)</label>
        <div style="display:flex;align-items:center;gap:0.5rem;">
          <input type="range" id="revenue-slider" min="100000" max="10000000" value="1000000" step="100000">
          <span class="value-display" id="revenue-value" style="min-width:7ch;">$1.0M</span>
        </div>
      </div>
    </div>
    <div class="impact-result-card" id="business-impact-cards"></div>
  </div>

  <hr class="divider">

  <!-- ── Weekly Forecast Change MAPEx Impact ── -->
  <h2>Weekly Forecast Change &mdash; MAPEx Impact</h2>
  <p>
    When you revise a forecast during a specific week, the change propagates differently
    across horizons. A <strong>5% improvement</strong> in week 1 forecasts might reduce H=7 MAPEx
    significantly but barely move H=35. The heatmap below shows how a forecast revision
    in each week affects MAPEx at every horizon.
  </p>

  <div class="vis-card">
    <h4>MAPEx Change from Weekly Forecast Revision</h4>
    <div class="controls">
      <div class="control-group">
        <label>Revision Size (%)</label>
        <div style="display:flex;align-items:center;gap:0.5rem;">
          <input type="range" id="revision-size-slider" min="1" max="20" value="5" step="1">
          <span class="value-display" id="revision-size-value">5%</span>
        </div>
      </div>
    </div>
    <table class="weekly-heatmap-table" id="weekly-heatmap-table">
      <thead>
        <tr>
          <th>Week Revised</th>
          <th>H=7d</th>
          <th>H=14d</th>
          <th>H=21d</th>
          <th>H=28d</th>
          <th>H=35d</th>
        </tr>
      </thead>
      <tbody id="weekly-heatmap-body"></tbody>
    </table>
    <p class="muted" style="margin-top:0.5rem;text-align:center;font-size:0.78rem;">
      Green = MAPEx improvement. Darker = bigger impact. Hover for details.
    </p>
    <div id="weekly-heatmap-detail" class="mape-result" style="display:none;font-size:0.95rem;"></div>
  </div>

  <hr class="divider">

  <!-- ── Re-forecast Frequency Guide ── -->
  <h2>When to Re-forecast</h2>
  <p>
    The shape of your MAPEx curve tells you how often you should update forecasts.
    If the curve is steep between adjacent horizons, frequent re-forecasting pays off.
    If it's flat, you can forecast less often without losing accuracy.
  </p>

  <div class="vis-card">
    <h4>Optimal Re-forecasting Frequency</h4>
    <div id="reforecast-chart"></div>
    <div id="reforecast-recommendation" class="reforecast-recommendation" style="margin-top:1rem;"></div>
  </div>

  <hr class="divider">

  <!-- ── Section 12: Takeaways ── -->
  <h2>Key Takeaways</h2>
  <div class="step-cards">
    <div class="step-card" style="border-color:var(--accent-mid)">
      <h5>MAPE is intuitive</h5>
      <p>A percentage-based error that's easy to communicate and compare across datasets.</p>
    </div>
    <div class="step-card" style="border-color:var(--accent-mid)">
      <h5>Horizon matters</h5>
      <p>MAPEx reveals how accuracy degrades as you forecast further ahead — essential for setting expectations.</p>
    </div>
    <div class="step-card" style="border-color:var(--accent-mid)">
      <h5>Know the limits</h5>
      <p>MAPE struggles with zeros, is asymmetric, and is sensitive to small actuals. Pair it with other metrics.</p>
    </div>
  </div>

</main>

<!-- ══════════════ FOOTER ══════════════ -->
<footer class="footer">
  <p>
    <strong>MAPEx</strong> — An interactive explainer on forecast accuracy.
    Built with <a href="https://d3js.org/" target="_blank" rel="noopener">D3.js</a>.
  </p>
</footer>

<!-- ══════════════ TOOLTIP ══════════════ -->
<div class="tooltip" id="tooltip"></div>

<!-- ══════════════ SCRIPTS ══════════════ -->
<script>
(function () {
  "use strict";

  const accent = "#6d28d9";
  const orange = "#ea580c";
  const teal = "#0d9488";
  const red = "#dc2626";
  const green = "#16a34a";
  const blue = "#2563eb";
  const textMuted = "#57534e";
  const border = "#e7e5e4";
  const ghost = "#d4d4d4";

  // Day-based horizons
  const HORIZONS = [7, 14, 21, 28, 35];

  // Dynamic "today" — always the current system date
  const TODAY = new Date();
  TODAY.setHours(0, 0, 0, 0);
  const fmt = d3.timeFormat("%b %d");
  const fmtFull = d3.timeFormat("%b %d, %Y");
  const fmtMonth = d3.timeFormat("%B");
  const fmtMonthShort = d3.timeFormat("%b");

  // Helper: add days to a date
  function addDays(date, n) {
    return new Date(date.getTime() + n * 86400000);
  }

  // Day-of-week names
  const dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];

  // Populate dynamic date spans across the site
  (function populateDynamicDates() {
    const dayName = dayNames[TODAY.getDay()];

    // Example callout: "On Monday Feb 16 with H=14..."
    var h14End = addDays(TODAY, 14);
    var el;
    el = document.getElementById("example-today");
    if (el) el.textContent = dayName + " " + fmt(TODAY);
    el = document.getElementById("example-range-start");
    if (el) el.textContent = fmt(TODAY);
    el = document.getElementById("example-range-end");
    if (el) el.textContent = fmt(h14End);
    el = document.getElementById("example-bucket-start");
    if (el) el.textContent = fmt(TODAY);
    el = document.getElementById("example-bucket-end");
    if (el) el.textContent = fmt(h14End);

    // Daily Versions Explained
    el = document.getElementById("dv-today");
    if (el) el.textContent = fmtFull(TODAY);

    var latestVersion = addDays(TODAY, -14 + 1); // Version whose bucket ends today
    var prevVersion = addDays(latestVersion, -1);
    var earliestVersion = addDays(TODAY, -14 - 14 + 1); // ~14 versions back
    var listEl = document.getElementById("dv-versions-list");
    if (listEl) {
      listEl.innerHTML =
        "<li><strong>Version " + fmt(latestVersion) + ":</strong> Bucket = " + fmt(latestVersion) + "&ndash;" + fmt(addDays(latestVersion, 13)) + " (14 days), all actuals available &#10003;</li>" +
        "<li><strong>Version " + fmt(prevVersion) + ":</strong> Bucket = " + fmt(prevVersion) + "&ndash;" + fmt(addDays(prevVersion, 13)) + " (14 days), all actuals available &#10003;</li>" +
        "<li>...going back to <strong>Version " + fmt(earliestVersion) + ":</strong> Bucket = " + fmt(earliestVersion) + " &ndash; " + fmt(addDays(earliestVersion, 13)) + "</li>";
    }

    var aggEl = document.getElementById("dv-aggregate-text");
    if (aggEl) {
      aggEl.innerHTML = "For " + fmtMonth(TODAY) + " MAPEx (H=14), we aggregate versions from <strong>" + fmt(earliestVersion) + " to " + fmt(latestVersion) + "</strong> (all versions where the bucket falls within or overlaps " + fmtMonth(TODAY) + " and actuals are available).";
    }

    // Horizon Lag description dates
    el = document.getElementById("lag-date-7");
    if (el) el.textContent = fmt(addDays(TODAY, 7));
    el = document.getElementById("lag-date-35");
    if (el) el.textContent = fmt(addDays(TODAY, 35));
  })();

  const tooltip = d3.select("#tooltip");

  function showTooltip(evt, html) {
    tooltip.html(html).style("opacity", 1);
    const ttNode = tooltip.node();
    const ttRect = ttNode.getBoundingClientRect();
    let left = evt.pageX + 12;
    let top = evt.pageY - 28;
    if (left + ttRect.width > window.innerWidth - 16) left = evt.pageX - ttRect.width - 12;
    tooltip.style("left", left + "px").style("top", top + "px");
  }

  function hideTooltip() { tooltip.style("opacity", 0); }

  /* ═══════════════════════════════════════
     1) Interactive MAPE Calculator Table
        Actuals are editable, Forecasts are constant
     ═══════════════════════════════════════ */
  const calcActuals = [100, 120, 90, 110, 105];
  const calcForecasts = [95, 130, 85, 100, 115]; // constant

  function renderCalcTable() {
    const tbody = d3.select("#calc-body");
    tbody.selectAll("tr").remove();

    let sumPctErr = 0;
    calcActuals.forEach((a, i) => {
      const f = calcForecasts[i];
      const pctErr = a !== 0 ? Math.abs(a - f) / Math.abs(a) : 0;
      sumPctErr += pctErr;

      const tr = tbody.append("tr");
      tr.append("td").text("t" + (i + 1));

      // Actual column: editable slider
      const tdA = tr.append("td");
      const inp = tdA.append("input")
        .attr("type", "range")
        .attr("min", Math.round(f * 0.5))
        .attr("max", Math.round(f * 2))
        .attr("value", a)
        .style("width", "90px");
      tdA.append("span")
        .attr("class", "col-actual")
        .style("margin-left", "0.4rem")
        .style("font-family", "var(--mono)")
        .text(a);

      // Forecast column: constant display
      tr.append("td").attr("class", "col-pred").text(f);

      tr.append("td").attr("class", "col-error").text((pctErr * 100).toFixed(1) + "%");

      inp.on("input", function () {
        calcActuals[i] = +this.value;
        renderCalcTable();
      });
    });

    const mape = (sumPctErr / calcActuals.length) * 100;
    d3.select("#mape-result").text("MAPE = " + mape.toFixed(2) + "%");
  }
  renderCalcTable();

  /* ═══════════════════════════════════════
     2) Time Series Forecast Chart
     ═══════════════════════════════════════ */
  function seededRandom(seed) {
    let s = seed;
    return function () {
      s = (s * 16807 + 0) % 2147483647;
      return (s - 1) / 2147483646;
    };
  }

  const rng = seededRandom(42);
  const N = 30;
  const actuals = [];
  let val = 100;
  for (let i = 0; i < N; i++) {
    val += (rng() - 0.45) * 8 + 0.3;
    val = Math.max(val, 20);
    actuals.push(Math.round(val * 10) / 10);
  }

  // Generate forecasts with error proportional to horizon (in days)
  function generateForecasts(horizonDays) {
    const rng2 = seededRandom(123 + horizonDays);
    const factor = horizonDays / 7; // normalise so day 7 ≈ old horizon 1
    return actuals.map((a, i) => {
      const noise = (rng2() - 0.5) * 2 * factor * 2.2;
      const drift = factor * 0.4 * (rng2() - 0.45);
      return Math.round((a + noise + drift) * 10) / 10;
    });
  }

  function computeMAPE(act, pred) {
    let sum = 0;
    let n = 0;
    act.forEach((a, i) => {
      if (a !== 0 && pred[i] !== undefined) {
        sum += Math.abs(a - pred[i]) / Math.abs(a);
        n++;
      }
    });
    return n > 0 ? (sum / n) * 100 : 0;
  }

  const tsMargin = { top: 20, right: 20, bottom: 35, left: 50 };
  const tsContainer = d3.select("#ts-chart");

  // Dynamic dates starting from TODAY
  const tsToday = TODAY;
  const tsDates = d3.range(N).map(i => addDays(tsToday, i));
  const tsDateFmt = d3.timeFormat("%b %d");

  function renderTSChart() {
    tsContainer.selectAll("*").remove();
    const cw = tsContainer.node().getBoundingClientRect().width;
    const width = cw;
    const height = Math.min(340, cw * 0.5);
    const iw = width - tsMargin.left - tsMargin.right;
    const ih = height - tsMargin.top - tsMargin.bottom;

    const sliderIdx = +d3.select("#horizon-slider").property("value");
    const horizonDays = HORIZONS[sliderIdx];
    d3.select("#horizon-value").text(horizonDays);
    const forecasts = generateForecasts(horizonDays);
    const mape = computeMAPE(actuals, forecasts);
    const targetDate = new Date(tsToday.getTime() + horizonDays * 86400000);
    d3.select("#ts-mape").text(
      "MAPE at horizon " + horizonDays + " days (target: " + tsDateFmt(targetDate) + ") = " + mape.toFixed(2) + "%"
    );

    const svg = tsContainer.append("svg")
      .attr("viewBox", `0 0 ${width} ${height}`)
      .attr("preserveAspectRatio", "xMidYMid meet");

    const g = svg.append("g").attr("transform", `translate(${tsMargin.left},${tsMargin.top})`);

    const x = d3.scaleTime().domain([tsDates[0], tsDates[N - 1]]).range([0, iw]);
    const allVals = actuals.concat(forecasts);
    const y = d3.scaleLinear().domain([d3.min(allVals) - 5, d3.max(allVals) + 5]).range([ih, 0]);

    // X axis: show exactly the 5 horizon dates
    const horizonTickDates = HORIZONS.map(h => addDays(tsToday, h));
    g.append("g").attr("transform", `translate(0,${ih})`)
      .call(d3.axisBottom(x).tickValues(horizonTickDates).tickFormat(d3.timeFormat("%b %d")))
      .call(g => g.select(".domain").attr("stroke", border))
      .call(g => g.selectAll(".tick line").attr("stroke", border))
      .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.6rem"));

    g.append("g")
      .call(d3.axisLeft(y).ticks(6))
      .call(g => g.select(".domain").attr("stroke", border))
      .call(g => g.selectAll(".tick line").attr("stroke", border))
      .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.65rem"));

    g.append("g").attr("class", "grid")
      .call(d3.axisLeft(y).ticks(6).tickSize(-iw).tickFormat(""))
      .call(g => g.select(".domain").remove())
      .call(g => g.selectAll(".tick line").attr("stroke", border).attr("stroke-opacity", 0.5));

    // Error area
    const area = d3.area()
      .x((d, i) => x(tsDates[i]))
      .y0((d, i) => y(Math.min(actuals[i], forecasts[i])))
      .y1((d, i) => y(Math.max(actuals[i], forecasts[i])))
      .curve(d3.curveMonotoneX);

    g.append("path").datum(actuals).attr("d", area)
      .attr("fill", "rgba(234,88,12,0.12)").attr("stroke", "none");

    const lineGen = d3.line().x((d, i) => x(tsDates[i])).y(d => y(d)).curve(d3.curveMonotoneX);

    g.append("path").datum(actuals).attr("d", lineGen)
      .attr("fill", "none").attr("stroke", teal).attr("stroke-width", 2.5);

    g.append("path").datum(forecasts).attr("d", lineGen)
      .attr("fill", "none").attr("stroke", orange).attr("stroke-width", 2).attr("stroke-dasharray", "6 3");

    g.selectAll(".dot-actual").data(actuals).enter()
      .append("circle")
      .attr("cx", (d, i) => x(tsDates[i])).attr("cy", d => y(d)).attr("r", 3).attr("fill", teal)
      .on("mouseover", function (evt, d) {
        const i = actuals.indexOf(d);
        showTooltip(evt, `${tsDateFmt(tsDates[i])}<br>Actual: ${d}<br>Forecast: ${forecasts[i]}<br>Error: ${(Math.abs(d - forecasts[i]) / Math.abs(d) * 100).toFixed(1)}%`);
      })
      .on("mousemove", function (evt) { showTooltip(evt, tooltip.html()); })
      .on("mouseout", hideTooltip);
  }

  renderTSChart();
  d3.select("#horizon-slider").on("input", renderTSChart);

  /* ═══════════════════════════════════════
     3) MAPEx Chart — MAPE vs Horizon (days)
        with ghost bars, confidence bands, naive
        baseline, and scenario support
     ═══════════════════════════════════════ */
  const mapexMargin = { top: 20, right: 30, bottom: 40, left: 55 };
  let previousMapexData = null;
  let currentScenario = "stable";

  // Scenario demand pattern generators
  const scenarios = {
    stable:     function(rng, i, base) { return base + (rng() - 0.5) * 3; },
    seasonal:   function(rng, i, base) { return base + Math.sin(i * 2 * Math.PI / 30) * 20 + (rng() - 0.5) * 4; },
    spike:      function(rng, i, base) { return base + (i >= 25 && i <= 35 ? 40 : 0) + (rng() - 0.5) * 4; },
    newproduct: function(rng, i, base) { return base * (0.3 + 0.7 * Math.min(i / 40, 1)) + (rng() - 0.5) * 5; }
  };

  function computeMapexData(noise, trend, scenario) {
    var sc = scenarios[scenario] || scenarios.stable;
    var N2 = 60;
    var nSim = 20; // simulations for confidence bands

    return HORIZONS.map(function(H) {
      var mapeList = [];
      var naiveMapeList = [];

      for (var sim = 0; sim < nSim; sim++) {
        var rng3 = seededRandom(77 + sim * 13);
        var act2 = [];
        var v = 100;
        for (var i = 0; i < N2; i++) {
          v = sc(rng3, i, v);
          v += (rng3() - 0.5) * noise * 1.5 + trend * 0.3;
          v = Math.max(v, 20);
          act2.push(Math.round(v * 10) / 10);
        }

        var rng4 = seededRandom(200 + H + sim * 7);
        var pred2 = act2.map(function(a) {
          var factor = H / 7;
          var n = (rng4() - 0.5) * 2 * factor * noise * 0.6;
          var d = factor * trend * 0.15 * (rng4() - 0.4);
          return a + n + d;
        });

        // Naive forecast: use last known value (persistence)
        var naive2 = act2.map(function(a, idx) {
          return idx >= H ? act2[idx - H] : a;
        });

        var totalTAE = 0, totalActuals = 0;
        var naiveTAE = 0, naiveActuals = 0;
        var maxV = N2 - H;
        for (var vi = 0; vi < maxV; vi++) {
          for (var d = vi; d < vi + H; d++) {
            totalTAE += Math.abs(pred2[d] - act2[d]);
            totalActuals += act2[d];
            naiveTAE += Math.abs(naive2[d] - act2[d]);
            naiveActuals += act2[d];
          }
        }
        if (totalActuals > 0) mapeList.push((totalTAE / totalActuals) * 100);
        if (naiveActuals > 0) naiveMapeList.push((naiveTAE / naiveActuals) * 100);
      }

      mapeList.sort(function(a, b) { return a - b; });
      naiveMapeList.sort(function(a, b) { return a - b; });
      var p10Idx = Math.floor(nSim * 0.1);
      var p90Idx = Math.floor(nSim * 0.9);
      var medianIdx = Math.floor(nSim * 0.5);

      return {
        horizon: H,
        mape: mapeList[medianIdx],
        p10: mapeList[p10Idx],
        p90: mapeList[p90Idx],
        naive: naiveMapeList[medianIdx]
      };
    });
  }

  function renderMAPExChart() {
    var container = d3.select("#mapex-chart");
    container.selectAll("*").remove();

    var noise = +d3.select("#noise-slider").property("value");
    var trend = +d3.select("#trend-slider").property("value");
    d3.select("#noise-value").text(noise);
    d3.select("#trend-value").text(trend);

    var mapexData = computeMapexData(noise, trend, currentScenario);

    var cw = container.node().getBoundingClientRect().width;
    var width = cw;
    var height = Math.min(360, cw * 0.55);
    var iw = width - mapexMargin.left - mapexMargin.right;
    var ih = height - mapexMargin.top - mapexMargin.bottom;

    // yMax includes bands + naive + ghost
    var allVals = [];
    mapexData.forEach(function(d) { allVals.push(d.mape, d.p90, d.naive); });
    if (previousMapexData) previousMapexData.forEach(function(d) { allVals.push(d.mape); });
    var yMax = d3.max(allVals) * 1.15;

    var svg = container.append("svg")
      .attr("viewBox", "0 0 " + width + " " + height)
      .attr("preserveAspectRatio", "xMidYMid meet");

    var g = svg.append("g").attr("transform", "translate(" + mapexMargin.left + "," + mapexMargin.top + ")");

    var x = d3.scaleBand().domain(HORIZONS).range([0, iw]).padding(0.25);
    var y = d3.scaleLinear().domain([0, yMax]).range([ih, 0]);

    var colorScale = d3.scaleSequential()
      .domain([0, yMax])
      .interpolator(d3.interpolateRgb(accent, orange));

    // Axes
    g.append("g").attr("transform", "translate(0," + ih + ")")
      .call(d3.axisBottom(x).tickFormat(function(d) { return d + "d"; }))
      .call(function(g) { g.select(".domain").attr("stroke", border); })
      .call(function(g) { g.selectAll(".tick line").attr("stroke", border); })
      .call(function(g) { g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.65rem"); });

    g.append("text").attr("x", iw / 2).attr("y", ih + 35)
      .attr("text-anchor", "middle").attr("fill", textMuted)
      .style("font-size", "0.72rem").text("Forecast Horizon (days)");

    g.append("g")
      .call(d3.axisLeft(y).ticks(6).tickFormat(function(d) { return d.toFixed(0) + "%"; }))
      .call(function(g) { g.select(".domain").attr("stroke", border); })
      .call(function(g) { g.selectAll(".tick line").attr("stroke", border); })
      .call(function(g) { g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.65rem"); });

    g.append("text").attr("transform", "rotate(-90)")
      .attr("x", -ih / 2).attr("y", -42)
      .attr("text-anchor", "middle").attr("fill", textMuted)
      .style("font-size", "0.72rem").text("MAPE (%)");

    // Grid
    g.append("g")
      .call(d3.axisLeft(y).ticks(6).tickSize(-iw).tickFormat(""))
      .call(function(g) { g.select(".domain").remove(); })
      .call(function(g) { g.selectAll(".tick line").attr("stroke", border).attr("stroke-opacity", 0.5); });

    // Confidence band (P10-P90 area)
    var bandArea = d3.area()
      .x(function(d) { return x(d.horizon) + x.bandwidth() / 2; })
      .y0(function(d) { return y(d.p10); })
      .y1(function(d) { return y(d.p90); })
      .curve(d3.curveMonotoneX);

    g.append("path").datum(mapexData).attr("d", bandArea)
      .attr("fill", "rgba(109,40,217,0.1)")
      .attr("stroke", "var(--accent-mid)").attr("stroke-width", 1)
      .attr("stroke-dasharray", "3 3").attr("opacity", 0.8);

    // Ghost bars (previous state)
    if (previousMapexData) {
      g.selectAll(".ghost-bar")
        .data(previousMapexData)
        .enter()
        .append("rect")
        .attr("class", "ghost-bar")
        .attr("x", function(d) { return x(d.horizon); })
        .attr("width", x.bandwidth())
        .attr("y", function(d) { return y(d.mape); })
        .attr("height", function(d) { return ih - y(d.mape); })
        .attr("rx", 4)
        .attr("fill", ghost)
        .attr("opacity", 0.5);

      var ghostLine = previousMapexData.map(function(d) { return [x(d.horizon) + x.bandwidth() / 2, y(d.mape)]; });
      g.append("path").datum(ghostLine)
        .attr("d", d3.line().curve(d3.curveMonotoneX))
        .attr("fill", "none").attr("stroke", ghost)
        .attr("stroke-width", 2).attr("stroke-dasharray", "3 4").attr("opacity", 0.6);
    }

    // Naive baseline line
    var naiveLine = d3.line()
      .x(function(d) { return x(d.horizon) + x.bandwidth() / 2; })
      .y(function(d) { return y(d.naive); })
      .curve(d3.curveMonotoneX);

    g.append("path").datum(mapexData).attr("d", naiveLine)
      .attr("fill", "none").attr("stroke", teal)
      .attr("stroke-width", 2).attr("stroke-dasharray", "6 4").attr("opacity", 0.5);

    // Naive baseline dots
    g.selectAll(".naive-dot").data(mapexData).enter()
      .append("circle")
      .attr("cx", function(d) { return x(d.horizon) + x.bandwidth() / 2; })
      .attr("cy", function(d) { return y(d.naive); })
      .attr("r", 3.5).attr("fill", teal).attr("opacity", 0.5);

    // Current bars
    g.selectAll(".horizon-bar")
      .data(mapexData)
      .enter()
      .append("rect")
      .attr("class", "horizon-bar")
      .attr("x", function(d) { return x(d.horizon); })
      .attr("width", x.bandwidth())
      .attr("y", ih).attr("height", 0)
      .attr("rx", 4)
      .attr("fill", function(d) { return colorScale(d.mape); })
      .on("mouseover", function (evt, d) {
        d3.select(this).attr("opacity", 0.8);
        var ttHtml = "Horizon: " + d.horizon + "d<br>Model MAPE: " + d.mape.toFixed(2) + "%";
        ttHtml += "<br>P10\u2013P90: " + d.p10.toFixed(1) + "\u2013" + d.p90.toFixed(1) + "%";
        ttHtml += "<br><span style='color:" + teal + "'>Naive: " + d.naive.toFixed(2) + "%</span>";
        if (previousMapexData) {
          var prev = previousMapexData.find(function(p) { return p.horizon === d.horizon; });
          if (prev) ttHtml += "<br><span style='color:" + ghost + "'>Previous: " + prev.mape.toFixed(2) + "%</span>";
        }
        showTooltip(evt, ttHtml);
      })
      .on("mousemove", function (evt) { showTooltip(evt, tooltip.html()); })
      .on("mouseout", function () { d3.select(this).attr("opacity", 1); hideTooltip(); })
      .transition().duration(600).delay(function(d, i) { return i * 50; })
      .attr("y", function(d) { return y(d.mape); })
      .attr("height", function(d) { return ih - y(d.mape); });

    // Value labels
    g.selectAll(".bar-label")
      .data(mapexData)
      .enter()
      .append("text")
      .attr("x", function(d) { return x(d.horizon) + x.bandwidth() / 2; })
      .attr("y", function(d) { return y(d.mape) - 6; })
      .attr("text-anchor", "middle").attr("fill", textMuted)
      .style("font-size", "0.6rem").style("font-family", "var(--mono)")
      .style("opacity", 0).text(function(d) { return d.mape.toFixed(1) + "%"; })
      .transition().duration(600).delay(function(d, i) { return i * 50 + 300; })
      .style("opacity", 1);

    // Trend line
    var lineData = mapexData.map(function(d) { return [x(d.horizon) + x.bandwidth() / 2, y(d.mape)]; });
    g.append("path").datum(lineData)
      .attr("d", d3.line().curve(d3.curveMonotoneX))
      .attr("fill", "none").attr("stroke", accent)
      .attr("stroke-width", 2).attr("stroke-dasharray", "4 3").attr("opacity", 0.5);

    // Store for ghost + downstream features
    previousMapexData = mapexData;

    // Trigger downstream renders that depend on MAPEx data
    renderBiasChart(noise, trend, currentScenario);
    renderBusinessImpact(mapexData);
    renderReforecastGuide(mapexData);
  }

  // Scenario button wiring
  d3.selectAll("#scenario-btns .scenario-btn").on("click", function() {
    d3.selectAll("#scenario-btns .scenario-btn").classed("active", false);
    d3.select(this).classed("active", true);
    currentScenario = d3.select(this).attr("data-scenario");
    renderMAPExChart();
  });

  renderMAPExChart();
  d3.select("#noise-slider").on("input", renderMAPExChart);
  d3.select("#trend-slider").on("input", renderMAPExChart);

  /* ═══════════════════════════════════════
     3b) Daily Versions Demo
     ═══════════════════════════════════════ */
  const dailyMargin = { top: 20, right: 30, bottom: 50, left: 60 };

  function renderDailyVersionsChart() {
    const container = d3.select("#daily-versions-chart");
    container.selectAll("*").remove();

    const H = +d3.select("#daily-horizon-select").property("value");
    const versionIdx = +d3.select("#version-slider").property("value");

    // Generate synthetic data: 50 days ending around today
    const nDays = 50;
    const todayIdx = nDays - 4; // "today" is near the end so buckets fit
    const startDate = addDays(TODAY, -todayIdx);
    const rngDaily = seededRandom(555);
    const dailyActuals = [];
    const dailyForecasts = [];
    let dv = 100;

    for (let i = 0; i < nDays; i++) {
      dv += (rngDaily() - 0.48) * 6 + 0.5;
      dv = Math.max(dv, 40);
      const actual = Math.round(dv * 10) / 10;
      dailyActuals.push(actual);
      const horizonFactor = H / 7;
      const forecast = actual + (rngDaily() - 0.5) * 10 * horizonFactor;
      dailyForecasts.push(Math.round(forecast * 10) / 10);
    }
    const maxVersionIdx = todayIdx - H + 1;
    const versions = [];
    for (let vi = Math.max(0, maxVersionIdx - 15); vi <= maxVersionIdx; vi++) {
      versions.push(vi);
    }

    d3.select("#version-slider").attr("max", versions.length - 1);
    const clampedIdx = Math.min(versionIdx, versions.length - 1);
    const currentVersionIdx = versions[clampedIdx];
    const versionDate = new Date(startDate.getTime() + currentVersionIdx * 86400000);
    const dvFmt = d3.timeFormat("%b %d");
    d3.select("#version-date-display").text(dvFmt(versionDate));

    // Compute TAE and Actuals for this version's bucket
    let tae = 0;
    let actualsSum = 0;
    for (let d = currentVersionIdx; d < currentVersionIdx + H && d < nDays; d++) {
      tae += Math.abs(dailyForecasts[d] - dailyActuals[d]);
      actualsSum += dailyActuals[d];
    }
    const versionMAPE = actualsSum > 0 ? (tae / actualsSum) * 100 : 0;
    const bucketEndDate = new Date(versionDate.getTime() + (H - 1) * 86400000);

    // Compute aggregate MAPEx across ALL versions for this horizon
    let totalTAE = 0;
    let totalActualsAll = 0;
    let versionCount = 0;
    for (let vi = Math.max(0, maxVersionIdx - 15); vi <= maxVersionIdx; vi++) {
      let vTAE = 0;
      let vAct = 0;
      for (let d = vi; d < vi + H && d < nDays; d++) {
        vTAE += Math.abs(dailyForecasts[d] - dailyActuals[d]);
        vAct += dailyActuals[d];
      }
      totalTAE += vTAE;
      totalActualsAll += vAct;
      versionCount++;
    }
    const aggregateMAPEx = totalActualsAll > 0 ? (totalTAE / totalActualsAll) * 100 : 0;

    d3.select("#version-stats").html(
      "<strong>Version " + dvFmt(versionDate) + ":</strong> Bucket [" + dvFmt(versionDate) + " \u2013 " + dvFmt(bucketEndDate) + "]<br>" +
      "TAE = " + tae.toFixed(1) + ", Actuals = " + actualsSum.toFixed(1) + ", MAPE = " + versionMAPE.toFixed(2) + "%" +
      "<br><strong style=\"color:var(--accent);\">Aggregate MAPEx (H=" + H + ", " + versionCount + " versions): " + aggregateMAPEx.toFixed(2) + "%</strong>"
    );

    // Draw chart with bucket highlighted
    const cw = container.node().getBoundingClientRect().width;
    const width = cw;
    const height = Math.min(300, cw * 0.45);
    const iw = width - dailyMargin.left - dailyMargin.right;
    const ih = height - dailyMargin.top - dailyMargin.bottom;

    const svg = container.append("svg")
      .attr("viewBox", "0 0 " + width + " " + height)
      .attr("preserveAspectRatio", "xMidYMid meet");

    const gd = svg.append("g").attr("transform", "translate(" + dailyMargin.left + "," + dailyMargin.top + ")");

    const dates = d3.range(nDays).map(i => new Date(startDate.getTime() + i * 86400000));
    const xd = d3.scaleTime().domain([dates[0], dates[nDays - 1]]).range([0, iw]);
    const yd = d3.scaleLinear().domain([30, d3.max(dailyActuals) + 10]).range([ih, 0]);

    // Highlight bucket region
    const bucketStart = dates[currentVersionIdx];
    const bucketEnd = dates[Math.min(currentVersionIdx + H - 1, nDays - 1)];
    gd.append("rect")
      .attr("x", xd(bucketStart))
      .attr("y", 0)
      .attr("width", xd(bucketEnd) - xd(bucketStart))
      .attr("height", ih)
      .attr("fill", "rgba(109,40,217,0.08)")
      .attr("stroke", accent)
      .attr("stroke-width", 1.5)
      .attr("stroke-dasharray", "4 3");

    // Axes
    gd.append("g").attr("transform", "translate(0," + ih + ")")
      .call(d3.axisBottom(xd).ticks(8).tickFormat(d3.timeFormat("%b %d")))
      .call(g => g.select(".domain").attr("stroke", border))
      .call(g => g.selectAll(".tick line").attr("stroke", border))
      .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.6rem"));

    gd.append("g")
      .call(d3.axisLeft(yd).ticks(5))
      .call(g => g.select(".domain").attr("stroke", border))
      .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.65rem"));

    // Grid
    gd.append("g")
      .call(d3.axisLeft(yd).ticks(5).tickSize(-iw).tickFormat(""))
      .call(g => g.select(".domain").remove())
      .call(g => g.selectAll(".tick line").attr("stroke", border).attr("stroke-opacity", 0.4));

    // Lines
    const dvLine = d3.line().x(function(d, i) { return xd(dates[i]); }).y(function(d) { return yd(d); }).curve(d3.curveMonotoneX);

    gd.append("path").datum(dailyActuals).attr("d", dvLine)
      .attr("fill", "none").attr("stroke", teal).attr("stroke-width", 2);

    gd.append("path").datum(dailyForecasts).attr("d", dvLine)
      .attr("fill", "none").attr("stroke", orange).attr("stroke-width", 1.5).attr("stroke-dasharray", "4 2");

    // Version date marker
    gd.append("line")
      .attr("x1", xd(versionDate)).attr("x2", xd(versionDate))
      .attr("y1", 0).attr("y2", ih)
      .attr("stroke", accent).attr("stroke-width", 2);

    gd.append("text")
      .attr("x", xd(versionDate))
      .attr("y", -5)
      .attr("text-anchor", "middle")
      .attr("fill", accent)
      .style("font-size", "0.7rem")
      .style("font-weight", "600")
      .text("Version Date");

    // Today marker
    if (todayIdx < nDays) {
      gd.append("line")
        .attr("x1", xd(dates[todayIdx])).attr("x2", xd(dates[todayIdx]))
        .attr("y1", 0).attr("y2", ih)
        .attr("stroke", red).attr("stroke-width", 1).attr("stroke-dasharray", "3 3");

      gd.append("text")
        .attr("x", xd(dates[todayIdx])).attr("y", -5)
        .attr("text-anchor", "middle").attr("fill", red)
        .style("font-size", "0.65rem").style("font-weight", "600")
        .text("Today");
    }
  }

  renderDailyVersionsChart();
  d3.select("#daily-horizon-select").on("change", renderDailyVersionsChart);
  d3.select("#version-slider").on("input", renderDailyVersionsChart);

  // Auto-play animation for Daily Versions
  var versionPlayTimer = null;
  d3.select("#version-play-btn").on("click", function() {
    var btn = d3.select(this);
    if (versionPlayTimer) {
      clearInterval(versionPlayTimer);
      versionPlayTimer = null;
      btn.classed("playing", false).text("Play");
      return;
    }
    btn.classed("playing", true).text("Pause");
    var slider = document.getElementById("version-slider");
    var maxVal = +slider.getAttribute("max");
    slider.value = 0;
    renderDailyVersionsChart();
    versionPlayTimer = setInterval(function() {
      var cur = +slider.value;
      if (cur >= maxVal) {
        clearInterval(versionPlayTimer);
        versionPlayTimer = null;
        btn.classed("playing", false).text("Play");
        return;
      }
      slider.value = cur + 1;
      renderDailyVersionsChart();
    }, 600);
  });

  /* ═══════════════════════════════════════
     3c) Forecast Revision Impact Grid
     ═══════════════════════════════════════ */
  function renderImpactGrid() {
    const tbody = d3.select("#impact-body");
    tbody.selectAll("*").remove();

    const weeks = ["Week 1", "Week 2", "Week 3", "Week 4"];
    const horizons = [7, 14, 21, 28, 35];

    const impactMap = {
      "Week 1": { 7: "M", 14: "M", 21: "M", 28: "M+1", 35: "M+1" },
      "Week 2": { 7: "M", 14: "M", 21: "M, M+1", 28: "M+1", 35: "M+1, M+2" },
      "Week 3": { 7: "M", 14: "M", 21: "M+1", 28: "M+1", 35: "M+2" },
      "Week 4": { 7: "M", 14: "M, M+1", 21: "M+1", 28: "M+1", 35: "M+2" }
    };

    weeks.forEach(function(week) {
      const tr = tbody.append("tr");
      tr.append("td").text(week).style("font-weight", "600");

      horizons.forEach(function(h) {
        const impact = impactMap[week][h];
        const td = tr.append("td").text(impact);

        if (impact === "M") td.attr("class", "current-month");
        else if (impact.indexOf(",") >= 0) td.attr("class", "both-months");
        else td.attr("class", "next-month");

        td.on("click", function() {
          const rngImpact = seededRandom(week.charCodeAt(5) * 100 + h);
          const improvement = (rngImpact() * 3 + 1).toFixed(2);
          d3.select("#impact-result")
            .style("display", "block")
            .html("<strong>Editing " + week + " forecasts improves H=" + h + " MAPE by " + improvement + "%</strong><br>" +
                  "<span style=\"font-size:0.8rem;\">Affected periods: " + impact + "</span>");
        });
      });
    });
  }

  renderImpactGrid();

  /* ═══════════════════════════════════════
     4) Benchmark / Interpretation Chart
     ═══════════════════════════════════════ */
  (function () {
    const benchmarks = [
      { label: "Excellent", range: "< 10%", lo: 0, hi: 10, color: "#16a34a" },
      { label: "Good", range: "10–20%", lo: 10, hi: 20, color: "#65a30d" },
      { label: "Reasonable", range: "20–30%", lo: 20, hi: 30, color: "#eab308" },
      { label: "Poor", range: "30–50%", lo: 30, hi: 50, color: "#f97316" },
      { label: "Inaccurate", range: "> 50%", lo: 50, hi: 70, color: "#dc2626" },
    ];

    const container = d3.select("#benchmark-chart");
    const cw = container.node().getBoundingClientRect().width;
    const width = cw;
    const height = 180;
    const margin = { top: 15, right: 20, bottom: 30, left: 90 };
    const iw = width - margin.left - margin.right;
    const ih = height - margin.top - margin.bottom;

    const svg = container.append("svg")
      .attr("viewBox", `0 0 ${width} ${height}`)
      .attr("preserveAspectRatio", "xMidYMid meet");

    const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

    const y = d3.scaleBand().domain(benchmarks.map(d => d.label)).range([0, ih]).padding(0.3);
    const x = d3.scaleLinear().domain([0, 70]).range([0, iw]);

    g.append("g")
      .call(d3.axisBottom(x).ticks(7).tickFormat(d => d + "%"))
      .attr("transform", `translate(0,${ih})`)
      .call(g => g.select(".domain").attr("stroke", border))
      .call(g => g.selectAll(".tick line").attr("stroke", border))
      .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.65rem"));

    g.append("g")
      .call(d3.axisLeft(y))
      .call(g => g.select(".domain").remove())
      .call(g => g.selectAll(".tick line").remove())
      .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.72rem").style("font-weight", "600"));

    g.selectAll(".bench-bar").data(benchmarks).enter()
      .append("rect")
      .attr("x", d => x(d.lo)).attr("y", d => y(d.label))
      .attr("width", 0).attr("height", y.bandwidth())
      .attr("rx", 4).attr("fill", d => d.color).attr("opacity", 0.8)
      .transition().duration(700).delay((d, i) => i * 80)
      .attr("width", d => x(d.hi) - x(d.lo));

    g.selectAll(".bench-label").data(benchmarks).enter()
      .append("text")
      .attr("x", d => x(d.hi) + 6)
      .attr("y", d => y(d.label) + y.bandwidth() / 2)
      .attr("dy", "0.35em").attr("fill", textMuted)
      .style("font-size", "0.65rem").style("font-family", "var(--mono)")
      .text(d => d.range);
  })();

  /* ═══════════════════════════════════════
     5) CSV Upload — custom MAPEx
     ═══════════════════════════════════════ */
  function parseCSV(text) {
    const lines = text.trim().split(/\r?\n/);
    if (lines.length < 2) return null;
    const headers = lines[0].toLowerCase().split(",").map(h => h.trim());
    const ai = headers.indexOf("actual");
    const fi = headers.indexOf("forecast");
    const hi = headers.indexOf("horizon");
    if (ai === -1 || fi === -1) return null;

    const rows = [];
    for (let i = 1; i < lines.length; i++) {
      const cols = lines[i].split(",").map(c => c.trim());
      if (!cols[ai] || !cols[fi]) continue;
      const row = { actual: +cols[ai], forecast: +cols[fi] };
      if (hi !== -1 && cols[hi]) row.horizon = +cols[hi];
      if (!isNaN(row.actual) && !isNaN(row.forecast)) rows.push(row);
    }
    return rows.length > 0 ? rows : null;
  }

  function renderCSVResult(rows) {
    const resultDiv = d3.select("#csv-result");
    resultDiv.style("display", "block");
    d3.select("#csv-mapex-chart").selectAll("*").remove();

    const hasHorizon = rows[0].horizon !== undefined;

    if (hasHorizon) {
      // Group by horizon and compute MAPE for each
      const grouped = d3.group(rows, d => d.horizon);
      const mapexData = [];
      grouped.forEach((vals, h) => {
        const act = vals.map(v => v.actual);
        const pred = vals.map(v => v.forecast);
        mapexData.push({ horizon: h, mape: computeMAPE(act, pred) });
      });
      mapexData.sort((a, b) => a.horizon - b.horizon);

      const overallAct = rows.map(r => r.actual);
      const overallPred = rows.map(r => r.forecast);
      const overallMape = computeMAPE(overallAct, overallPred);
      d3.select("#csv-mape-result").text("Overall MAPE = " + overallMape.toFixed(2) + "%");

      // Draw MAPEx bar chart
      const container = d3.select("#csv-mapex-chart");
      const cw = container.node().getBoundingClientRect().width;
      const width = cw;
      const height = Math.min(300, cw * 0.5);
      const margin = { top: 20, right: 20, bottom: 40, left: 55 };
      const iw = width - margin.left - margin.right;
      const ih = height - margin.top - margin.bottom;

      const svg = container.append("svg")
        .attr("viewBox", `0 0 ${width} ${height}`)
        .attr("preserveAspectRatio", "xMidYMid meet");

      const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

      const x = d3.scaleBand().domain(mapexData.map(d => d.horizon)).range([0, iw]).padding(0.35);
      const yMax = d3.max(mapexData, d => d.mape) * 1.15;
      const y = d3.scaleLinear().domain([0, yMax]).range([ih, 0]);

      const colorScale = d3.scaleSequential()
        .domain([0, yMax]).interpolator(d3.interpolateRgb(accent, orange));

      g.append("g").attr("transform", `translate(0,${ih})`)
        .call(d3.axisBottom(x).tickFormat(d => d + "d"))
        .call(g => g.select(".domain").attr("stroke", border))
        .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.65rem"));

      g.append("g")
        .call(d3.axisLeft(y).ticks(5).tickFormat(d => d.toFixed(0) + "%"))
        .call(g => g.select(".domain").attr("stroke", border))
        .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.65rem"));

      g.append("g")
        .call(d3.axisLeft(y).ticks(5).tickSize(-iw).tickFormat(""))
        .call(g => g.select(".domain").remove())
        .call(g => g.selectAll(".tick line").attr("stroke", border).attr("stroke-opacity", 0.5));

      g.selectAll(".csv-bar").data(mapexData).enter()
        .append("rect")
        .attr("x", d => x(d.horizon)).attr("width", x.bandwidth())
        .attr("y", ih).attr("height", 0).attr("rx", 4)
        .attr("fill", d => colorScale(d.mape))
        .on("mouseover", function(evt, d) {
          showTooltip(evt, `Horizon: ${d.horizon} days<br>MAPE: ${d.mape.toFixed(2)}%`);
        })
        .on("mouseout", hideTooltip)
        .transition().duration(600).delay((d, i) => i * 60)
        .attr("y", d => y(d.mape)).attr("height", d => ih - y(d.mape));

      g.selectAll(".csv-label").data(mapexData).enter()
        .append("text")
        .attr("x", d => x(d.horizon) + x.bandwidth() / 2)
        .attr("y", d => y(d.mape) - 6)
        .attr("text-anchor", "middle").attr("fill", textMuted)
        .style("font-size", "0.6rem").style("font-family", "var(--mono)")
        .text(d => d.mape.toFixed(1) + "%");

    } else {
      // No horizon column — just show overall MAPE
      const act = rows.map(r => r.actual);
      const pred = rows.map(r => r.forecast);
      const mape = computeMAPE(act, pred);
      d3.select("#csv-mape-result").text("MAPE = " + mape.toFixed(2) + "% (" + rows.length + " rows)");
      d3.select("#csv-mapex-chart").append("p")
        .attr("class", "muted")
        .style("text-align", "center").style("font-size", "0.82rem")
        .text("Add a \"horizon\" column (e.g. 7, 14, 21, 28, 35) to see a MAPEx curve.");
    }
  }

  // File upload handler
  d3.select("#csv-upload").on("change", function () {
    const file = this.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function (e) {
      const rows = parseCSV(e.target.result);
      if (!rows) {
        d3.select("#csv-status").text("Could not parse CSV. Ensure it has \"actual\" and \"forecast\" columns.");
        d3.select("#csv-result").style("display", "none");
        return;
      }
      d3.select("#csv-status").text("Loaded " + rows.length + " rows from " + file.name);
      renderCSVResult(rows);
    };
    reader.readAsText(file);
  });

  // Sample data button
  d3.select("#csv-sample-btn").on("click", function () {
    const sampleCSV = [
      "actual,forecast,horizon",
      "100,97,7", "120,115,7", "90,88,7", "110,108,7", "105,101,7",
      "100,92,14", "120,110,14", "90,82,14", "110,100,14", "105,95,14",
      "100,88,21", "120,105,21", "90,78,21", "110,95,21", "105,90,21",
      "100,82,28", "120,98,28", "90,72,28", "110,88,28", "105,84,28",
      "100,75,35", "120,92,35", "90,68,35", "110,82,35", "105,78,35"
    ].join("\n");
    const rows = parseCSV(sampleCSV);
    d3.select("#csv-status").text("Loaded sample data (25 rows across 5 horizons)");
    renderCSVResult(rows);
  });

  /* ═══════════════════════════════════════
     6) Horizon Lag Visualization
     ═══════════════════════════════════════ */
  (function () {
    const container = d3.select("#lag-chart");
    const cw = container.node().getBoundingClientRect().width;
    const width = cw;
    const height = Math.min(320, cw * 0.5);
    const margin = { top: 25, right: 30, bottom: 35, left: 55 };
    const iw = width - margin.left - margin.right;
    const ih = height - margin.top - margin.bottom;

    const svg = container.append("svg")
      .attr("viewBox", `0 0 ${width} ${height}`)
      .attr("preserveAspectRatio", "xMidYMid meet");

    const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

    // Generate a synthetic daily series: 25 days before today + 35 days after
    const rngL = seededRandom(99);
    const daysBefore = 25;
    const daysAfter = 36; // enough to cover max horizon (35d)
    const nDays = daysBefore + daysAfter;
    const series = [];
    let sv = 100;
    for (let i = 0; i < nDays; i++) {
      sv += (rngL() - 0.48) * 5 + 0.2;
      sv = Math.max(sv, 30);
      series.push(sv);
    }

    const todayLag = daysBefore; // index of "today" in the series
    const lagStartDate = addDays(TODAY, -daysBefore);
    const lagDates = d3.range(nDays).map(function(i) { return addDays(lagStartDate, i); });

    const x = d3.scaleTime().domain([lagDates[0], lagDates[nDays - 1]]).range([0, iw]);
    const y = d3.scaleLinear().domain([d3.min(series) - 5, d3.max(series) + 10]).range([ih, 0]);

    // X axis with real dates — show Today + each horizon target date
    var lagTickDates = [TODAY].concat(HORIZONS.map(function(h) { return addDays(TODAY, h); }));
    g.append("g").attr("transform", `translate(0,${ih})`)
      .call(d3.axisBottom(x).tickValues(lagTickDates).tickFormat(d3.timeFormat("%b %d")))
      .call(g => g.select(".domain").attr("stroke", border))
      .call(g => g.selectAll(".tick line").attr("stroke", border))
      .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.55rem"));

    // Y axis
    g.append("g")
      .call(d3.axisLeft(y).ticks(5))
      .call(g => g.select(".domain").attr("stroke", border))
      .call(g => g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.6rem"));

    // Grid
    g.append("g")
      .call(d3.axisLeft(y).ticks(5).tickSize(-iw).tickFormat(""))
      .call(g => g.select(".domain").remove())
      .call(g => g.selectAll(".tick line").attr("stroke", border).attr("stroke-opacity", 0.4));

    // Known data (up to "today")
    const knownData = series.slice(0, todayLag + 1);
    const knownDates = lagDates.slice(0, todayLag + 1);
    const lineGen = d3.line().x(function(d, i) { return x(knownDates[i]); }).y(function(d) { return y(d); }).curve(d3.curveMonotoneX);

    g.append("path").datum(knownData).attr("d", lineGen)
      .attr("fill", "none").attr("stroke", teal).attr("stroke-width", 2.5);

    // "Today" vertical line
    g.append("line")
      .attr("x1", x(TODAY)).attr("x2", x(TODAY))
      .attr("y1", 0).attr("y2", ih)
      .attr("stroke", accent).attr("stroke-width", 1.5).attr("stroke-dasharray", "4 3");

    g.append("text")
      .attr("x", x(TODAY)).attr("y", -8)
      .attr("text-anchor", "middle").attr("fill", accent)
      .style("font-size", "0.7rem").style("font-weight", "600").text("Today (" + fmt(TODAY) + ")");

    // For each horizon, draw the lag gap and prediction point
    const horizonColors = ["#16a34a", "#2563eb", "#8b5cf6", "#ea580c", "#dc2626"];

    HORIZONS.forEach(function(h, idx) {
      const targetDayIdx = todayLag + h;
      if (targetDayIdx >= nDays) return;

      const targetDate = lagDates[targetDayIdx];
      const targetVal = series[targetDayIdx];
      const color = horizonColors[idx];

      // Dashed lag line
      g.append("line")
        .attr("x1", x(TODAY)).attr("x2", x(targetDate))
        .attr("y1", y(targetVal)).attr("y2", y(targetVal))
        .attr("stroke", color).attr("stroke-width", 1.5)
        .attr("stroke-dasharray", "3 3").attr("opacity", 0.7);

      // Prediction target dot
      g.append("circle")
        .attr("cx", x(targetDate)).attr("cy", y(targetVal))
        .attr("r", 5).attr("fill", color).attr("stroke", "#fff").attr("stroke-width", 1.5);

      // Future series (faded)
      const futureSlice = series.slice(todayLag, targetDayIdx + 1);
      const futureDates = lagDates.slice(todayLag, targetDayIdx + 1);
      const futureLine = d3.line()
        .x(function(d, i) { return x(futureDates[i]); })
        .y(function(d) { return y(d); })
        .curve(d3.curveMonotoneX);

      g.append("path").datum(futureSlice).attr("d", futureLine)
        .attr("fill", "none").attr("stroke", color)
        .attr("stroke-width", 1).attr("stroke-dasharray", "2 3").attr("opacity", 0.35);

      // Horizon label with date
      g.append("text")
        .attr("x", x(targetDate) + 6).attr("y", y(targetVal) + 4)
        .attr("fill", color).style("font-size", "0.6rem").style("font-weight", "600")
        .text(h + "d (" + fmt(targetDate) + ")");
    });

    // Shaded "known" region
    const knownArea = d3.area()
      .x(function(d, i) { return x(knownDates[i]); })
      .y0(ih)
      .y1(function(d) { return y(d); })
      .curve(d3.curveMonotoneX);

    g.insert("path", ":first-child").datum(knownData).attr("d", knownArea)
      .attr("fill", teal).attr("opacity", 0.06);

  })();

  /* ═══════════════════════════════════════
     7) Bias Chart — Signed Error by Horizon
     ═══════════════════════════════════════ */
  function renderBiasChart(noise, trend, scenario) {
    var container = d3.select("#bias-chart");
    container.selectAll("*").remove();
    var sc = scenarios[scenario] || scenarios.stable;
    var N2 = 60;

    var biasData = HORIZONS.map(function(H) {
      var rng3 = seededRandom(77);
      var act2 = [];
      var v = 100;
      for (var i = 0; i < N2; i++) {
        v = sc(rng3, i, v);
        v += (rng3() - 0.5) * noise * 1.5 + trend * 0.3;
        v = Math.max(v, 20);
        act2.push(Math.round(v * 10) / 10);
      }
      var rng4 = seededRandom(200 + H);
      var signedErrors = [];
      for (var idx = 0; idx < act2.length; idx++) {
        var factor = H / 7;
        var n = (rng4() - 0.5) * 2 * factor * noise * 0.6;
        var d = factor * trend * 0.15 * (rng4() - 0.4);
        var pred = act2[idx] + n + d;
        signedErrors.push(((pred - act2[idx]) / act2[idx]) * 100);
      }
      var meanBias = d3.mean(signedErrors);
      return { horizon: H, bias: meanBias };
    });

    var cw = container.node().getBoundingClientRect().width;
    var width = cw;
    var height = Math.min(280, cw * 0.45);
    var margin = { top: 20, right: 30, bottom: 40, left: 55 };
    var iw = width - margin.left - margin.right;
    var ih = height - margin.top - margin.bottom;

    var svg = container.append("svg")
      .attr("viewBox", "0 0 " + width + " " + height)
      .attr("preserveAspectRatio", "xMidYMid meet");

    var g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    var allBias = biasData.map(function(d) { return Math.abs(d.bias); });
    var yExtent = d3.max(allBias) * 1.3;

    var x = d3.scaleBand().domain(HORIZONS).range([0, iw]).padding(0.3);
    var y = d3.scaleLinear().domain([-yExtent, yExtent]).range([ih, 0]);

    g.append("g").attr("transform", "translate(0," + ih + ")")
      .call(d3.axisBottom(x).tickFormat(function(d) { return d + "d"; }))
      .call(function(g) { g.select(".domain").attr("stroke", border); })
      .call(function(g) { g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.65rem"); });

    g.append("g")
      .call(d3.axisLeft(y).ticks(6).tickFormat(function(d) { return d.toFixed(0) + "%"; }))
      .call(function(g) { g.select(".domain").attr("stroke", border); })
      .call(function(g) { g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.65rem"); });

    // Zero line
    g.append("line")
      .attr("x1", 0).attr("x2", iw)
      .attr("y1", y(0)).attr("y2", y(0))
      .attr("stroke", border).attr("stroke-width", 2);

    // Bars
    g.selectAll(".bias-bar").data(biasData).enter()
      .append("rect")
      .attr("x", function(d) { return x(d.horizon); })
      .attr("width", x.bandwidth())
      .attr("y", function(d) { return d.bias >= 0 ? y(d.bias) : y(0); })
      .attr("height", function(d) { return Math.abs(y(d.bias) - y(0)); })
      .attr("rx", 4)
      .attr("fill", function(d) { return d.bias >= 0 ? orange : teal; })
      .attr("opacity", 0.8)
      .on("mouseover", function(evt, d) {
        showTooltip(evt, "H=" + d.horizon + "d<br>Mean bias: " + (d.bias >= 0 ? "+" : "") + d.bias.toFixed(2) + "%<br>" + (d.bias >= 0 ? "Over-forecasting" : "Under-forecasting"));
      })
      .on("mouseout", hideTooltip);

    // Value labels
    g.selectAll(".bias-label").data(biasData).enter()
      .append("text")
      .attr("x", function(d) { return x(d.horizon) + x.bandwidth() / 2; })
      .attr("y", function(d) { return d.bias >= 0 ? y(d.bias) - 6 : y(d.bias) + 14; })
      .attr("text-anchor", "middle").attr("fill", textMuted)
      .style("font-size", "0.6rem").style("font-family", "var(--mono)")
      .text(function(d) { return (d.bias >= 0 ? "+" : "") + d.bias.toFixed(1) + "%"; });

    // Summary
    var avgBias = d3.mean(biasData, function(d) { return d.bias; });
    var biasDir = avgBias >= 0 ? "over-forecasting" : "under-forecasting";
    d3.select("#bias-summary").html(
      "Average bias: <strong>" + (avgBias >= 0 ? "+" : "") + avgBias.toFixed(2) + "%</strong> (" + biasDir + ")"
    );
  }

  /* ═══════════════════════════════════════
     8) Business Impact Translator
     ═══════════════════════════════════════ */
  function renderBusinessImpact(mapexData) {
    if (!mapexData) return;
    var container = d3.select("#business-impact-cards");
    container.selectAll("*").remove();

    var revenue = +d3.select("#revenue-slider").property("value");
    var revLabel = revenue >= 1000000 ? "$" + (revenue / 1000000).toFixed(1) + "M" : "$" + (revenue / 1000).toFixed(0) + "K";
    d3.select("#revenue-value").text(revLabel);

    mapexData.forEach(function(d) {
      var dollarImpact = revenue * (d.mape / 100);
      var impactLabel = dollarImpact >= 1000000 ? "$" + (dollarImpact / 1000000).toFixed(2) + "M" : dollarImpact >= 1000 ? "$" + (dollarImpact / 1000).toFixed(0) + "K" : "$" + dollarImpact.toFixed(0);

      var card = container.append("div").attr("class", "impact-metric");
      card.append("div").attr("class", "metric-value").text(impactLabel);
      card.append("div").attr("class", "metric-label").text("H=" + d.horizon + "d (" + d.mape.toFixed(1) + "%)");
    });
  }

  d3.select("#revenue-slider").on("input", function() {
    if (previousMapexData) renderBusinessImpact(previousMapexData);
  });

  /* ═══════════════════════════════════════
     9) Weekly Forecast Change MAPEx Impact
     ═══════════════════════════════════════ */
  function renderWeeklyHeatmap() {
    var tbody = d3.select("#weekly-heatmap-body");
    tbody.selectAll("*").remove();

    var revisionPct = +d3.select("#revision-size-slider").property("value");
    d3.select("#revision-size-value").text(revisionPct + "%");

    var weeks = [
      { label: "Week 1 (" + fmt(TODAY) + ")", weekStart: 0 },
      { label: "Week 2 (" + fmt(addDays(TODAY, 7)) + ")", weekStart: 7 },
      { label: "Week 3 (" + fmt(addDays(TODAY, 14)) + ")", weekStart: 14 },
      { label: "Week 4 (" + fmt(addDays(TODAY, 21)) + ")", weekStart: 21 }
    ];

    // Simulate: revising forecasts in each week affects horizons differently
    // The logic: if you improve week W forecasts, horizon H is affected
    // proportional to how much of the H-day bucket overlaps with that week
    weeks.forEach(function(week) {
      var tr = tbody.append("tr");
      tr.append("td").text(week.label).style("font-weight", "600").style("font-size", "0.72rem");

      HORIZONS.forEach(function(H) {
        // Days in the horizon bucket that overlap with this week
        var overlapDays = 0;
        for (var d = 0; d < H; d++) {
          var dayInFuture = d;
          if (dayInFuture >= week.weekStart && dayInFuture < week.weekStart + 7) {
            overlapDays++;
          }
        }

        var overlapFraction = overlapDays / H;
        // MAPEx improvement = revision% * overlap fraction * decay factor
        var decayFactor = 1 / (1 + week.weekStart / 14); // further weeks have less impact
        var improvement = revisionPct * overlapFraction * decayFactor;

        var intensity = Math.min(improvement / (revisionPct * 0.8), 1);
        var bgColor = "rgba(22,163,74," + (intensity * 0.35) + ")"; // green

        var td = tr.append("td")
          .text(improvement > 0.01 ? "-" + improvement.toFixed(2) + "%" : "--")
          .style("background", bgColor)
          .style("color", improvement > 0.01 ? green : textMuted);

        td.on("mouseover", function(evt) {
          showTooltip(evt,
            "Revising " + week.label + " forecasts by " + revisionPct + "%<br>" +
            "Horizon: " + H + " days<br>" +
            "Overlap: " + overlapDays + "/" + H + " days (" + (overlapFraction * 100).toFixed(0) + "%)<br>" +
            "MAPEx improvement: " + (improvement > 0.01 ? "-" + improvement.toFixed(2) + "%" : "negligible")
          );
        }).on("mouseout", hideTooltip);

        td.on("click", function() {
          d3.select("#weekly-heatmap-detail")
            .style("display", "block")
            .html(
              "<strong>Revising Week " + ((week.weekStart / 7) + 1) + " forecasts (" + fmt(addDays(TODAY, week.weekStart)) + " \u2013 " + fmt(addDays(TODAY, week.weekStart + 6)) + ")</strong><br>" +
              "At H=" + H + "d: " + overlapDays + " of " + H + " days overlap (" + (overlapFraction * 100).toFixed(0) + "%), " +
              "expected MAPEx improvement: <strong style='color:" + green + "'>" + (improvement > 0.01 ? "-" + improvement.toFixed(2) + "%" : "negligible") + "</strong>"
            );
        });
      });
    });
  }

  renderWeeklyHeatmap();
  d3.select("#revision-size-slider").on("input", renderWeeklyHeatmap);

  /* ═══════════════════════════════════════
     10) Re-forecast Frequency Guide
     ═══════════════════════════════════════ */
  function renderReforecastGuide(mapexData) {
    if (!mapexData || mapexData.length < 2) return;

    var container = d3.select("#reforecast-chart");
    container.selectAll("*").remove();

    // Compute marginal increase between consecutive horizons
    var marginals = [];
    for (var i = 1; i < mapexData.length; i++) {
      var increase = mapexData[i].mape - mapexData[i - 1].mape;
      var perDay = increase / (mapexData[i].horizon - mapexData[i - 1].horizon);
      marginals.push({
        from: mapexData[i - 1].horizon,
        to: mapexData[i].horizon,
        label: mapexData[i - 1].horizon + "d\u2192" + mapexData[i].horizon + "d",
        increase: increase,
        perDay: perDay
      });
    }

    var cw = container.node().getBoundingClientRect().width;
    var width = cw;
    var height = Math.min(260, cw * 0.4);
    var margin = { top: 20, right: 30, bottom: 40, left: 55 };
    var iw = width - margin.left - margin.right;
    var ih = height - margin.top - margin.bottom;

    var svg = container.append("svg")
      .attr("viewBox", "0 0 " + width + " " + height)
      .attr("preserveAspectRatio", "xMidYMid meet");

    var g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    var x = d3.scaleBand().domain(marginals.map(function(d) { return d.label; })).range([0, iw]).padding(0.3);
    var yMax = d3.max(marginals, function(d) { return d.increase; }) * 1.2;
    var y = d3.scaleLinear().domain([0, yMax]).range([ih, 0]);

    g.append("g").attr("transform", "translate(0," + ih + ")")
      .call(d3.axisBottom(x))
      .call(function(g) { g.select(".domain").attr("stroke", border); })
      .call(function(g) { g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.6rem"); });

    g.append("g")
      .call(d3.axisLeft(y).ticks(5).tickFormat(function(d) { return "+" + d.toFixed(1) + "%"; }))
      .call(function(g) { g.select(".domain").attr("stroke", border); })
      .call(function(g) { g.selectAll(".tick text").attr("fill", textMuted).style("font-size", "0.6rem"); });

    g.append("text").attr("transform", "rotate(-90)")
      .attr("x", -ih / 2).attr("y", -42)
      .attr("text-anchor", "middle").attr("fill", textMuted)
      .style("font-size", "0.68rem").text("Marginal MAPE Increase");

    // Grid
    g.append("g")
      .call(d3.axisLeft(y).ticks(5).tickSize(-iw).tickFormat(""))
      .call(function(g) { g.select(".domain").remove(); })
      .call(function(g) { g.selectAll(".tick line").attr("stroke", border).attr("stroke-opacity", 0.4); });

    // Color scale: steeper = more red/orange
    var barColor = d3.scaleSequential()
      .domain([0, yMax])
      .interpolator(d3.interpolateRgb(green, red));

    g.selectAll(".marginal-bar").data(marginals).enter()
      .append("rect")
      .attr("x", function(d) { return x(d.label); })
      .attr("width", x.bandwidth())
      .attr("y", function(d) { return y(d.increase); })
      .attr("height", function(d) { return ih - y(d.increase); })
      .attr("rx", 4)
      .attr("fill", function(d) { return barColor(d.increase); })
      .attr("opacity", 0.85)
      .on("mouseover", function(evt, d) {
        showTooltip(evt, d.label + "<br>MAPE increase: +" + d.increase.toFixed(2) + "%<br>Per day: +" + d.perDay.toFixed(3) + "%/day");
      })
      .on("mouseout", hideTooltip);

    g.selectAll(".marginal-label").data(marginals).enter()
      .append("text")
      .attr("x", function(d) { return x(d.label) + x.bandwidth() / 2; })
      .attr("y", function(d) { return y(d.increase) - 5; })
      .attr("text-anchor", "middle").attr("fill", textMuted)
      .style("font-size", "0.58rem").style("font-family", "var(--mono)")
      .text(function(d) { return "+" + d.increase.toFixed(1) + "%"; });

    // Generate recommendation
    var steepest = marginals.reduce(function(a, b) { return a.perDay > b.perDay ? a : b; });
    var flattest = marginals.reduce(function(a, b) { return a.perDay < b.perDay ? a : b; });
    var avgPerDay = d3.mean(marginals, function(d) { return d.perDay; });

    var recText = "";
    var recIcon = "";
    if (avgPerDay > 0.15) {
      recIcon = "&#9888;";
      recText = "Your MAPEx curve is <strong>steep</strong> (avg +" + avgPerDay.toFixed(2) + "%/day). " +
        "The steepest segment is <strong>" + steepest.label + "</strong> (+" + steepest.perDay.toFixed(3) + "%/day). " +
        "Consider <strong>daily or every-other-day</strong> re-forecasting to capture fast-moving changes.";
    } else if (avgPerDay > 0.05) {
      recIcon = "&#128337;";
      recText = "Your MAPEx curve has <strong>moderate slope</strong> (avg +" + avgPerDay.toFixed(2) + "%/day). " +
        "The steepest jump is at <strong>" + steepest.label + "</strong>. " +
        "<strong>Weekly</strong> re-forecasting should capture most accuracy gains.";
    } else {
      recIcon = "&#9989;";
      recText = "Your MAPEx curve is <strong>relatively flat</strong> (avg +" + avgPerDay.toFixed(2) + "%/day). " +
        "Even <strong>bi-weekly or monthly</strong> re-forecasting should maintain reasonable accuracy. " +
        "The flattest segment: <strong>" + flattest.label + "</strong>.";
    }

    d3.select("#reforecast-recommendation").html(
      "<div class='rec-icon'>" + recIcon + "</div><div class='rec-text'>" + recText + "</div>"
    );
  }

  /* ═══════════════════════════════════════
     11) Responsive resize
     ═══════════════════════════════════════ */
  let resizeTimer;
  window.addEventListener("resize", () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => {
      renderTSChart();
      previousMapexData = null;
      renderMAPExChart();
      renderDailyVersionsChart();
      renderWeeklyHeatmap();
    }, 200);
  });

  /* ═══════════════════════════════════════
     8) KaTeX Formula Rendering
     ═══════════════════════════════════════ */
  function renderKaTeX() {
    var mapeEl = document.getElementById('mape-formula');
    var mapexEl = document.getElementById('mapex-formula-daily');

    if (typeof katex !== 'undefined') {
      if (mapeEl) {
        katex.render(
          String.raw`\text{MAPE} = \frac{100\%}{n} \times \sum_{t=1}^{n} \frac{|A_t - F_t|}{|A_t|}`,
          mapeEl,
          { displayMode: true, throwOnError: false }
        );
      }
      if (mapexEl) {
        katex.render(
          String.raw`\text{MAPEx}_H = \frac{\displaystyle\sum_{\text{all versions}} \text{TAE}_v}{\displaystyle\sum_{\text{all versions}} \text{Actuals}_v}`,
          mapexEl,
          { displayMode: true, throwOnError: false }
        );
      }
    }
  }

  // Wait for KaTeX to load then render
  if (typeof katex !== 'undefined') {
    renderKaTeX();
  } else {
    var katexScript = document.querySelector('script[src*="katex"]');
    if (katexScript) {
      katexScript.addEventListener('load', renderKaTeX);
    }
    // Fallback: poll for katex
    var katexPoll = setInterval(function() {
      if (typeof katex !== 'undefined') {
        clearInterval(katexPoll);
        renderKaTeX();
      }
    }, 100);
    setTimeout(function() { clearInterval(katexPoll); }, 5000);
  }

  /* ═══════════════════════════════════════
     9) Intersection observer for animations
     ═══════════════════════════════════════ */
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        entry.target.style.opacity = "1";
        entry.target.style.transform = "translateY(0)";
      }
    });
  }, { threshold: 0.15 });

  document.querySelectorAll(".vis-card, .step-card, .callout, .formula-card").forEach(el => {
    el.style.opacity = "0";
    el.style.transform = "translateY(20px)";
    el.style.transition = "opacity 0.6s ease, transform 0.6s ease";
    observer.observe(el);
  });

})();
</script>
</body>
</html>
